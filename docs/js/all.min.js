    /* Resources.js
 * This is simply an image loading utility. It eases the process of loading
 * image files so that they can be used within your game. It also includes
 * a simple "caching" layer so it will reuse cached images if you attempt
 * to load the same image multiple times.
 */
(function() {
    var resourceCache = {};
    var loading = [];
    var readyCallbacks = [];

    /* This is the publicly accessible image loading function. It accepts
     * an array of strings pointing to image files or a string for a single
     * image. It will then call our private image loading function accordingly.
     */
    function load(urlOrArr) {
        if(urlOrArr instanceof Array) {
            /* If the developer passed in an array of images
             * loop through each value and call our image
             * loader on that image file
             */
            urlOrArr.forEach(function(url) {
                _load(url);
            });
        } else {
            /* The developer did not pass an array to this function,
             * assume the value is a string and call our image loader
             * directly.
             */
            _load(urlOrArr);
        }
    }

    /* This is our private image loader function, it is
     * called by the public image loader function.
     */
    function _load(url) {
        if(resourceCache[url]) {
            /* If this URL has been previously loaded it will exist within
             * our resourceCache array. Just return that image rather
             * re-loading the image.
             */
            return resourceCache[url];
        } else {
            /* This URL has not been previously loaded and is not present
             * within our cache; we'll need to load this image.
             */
            var img = new Image();
            img.onload = function() {
                /* Once our image has properly loaded, add it to our cache
                 * so that we can simply return this image if the developer
                 * attempts to load this file in the future.
                 */
                resourceCache[url] = img;

                /* Once the image is actually loaded and properly cached,
                 * call all of the onReady() callbacks we have defined.
                 */
                if(isReady()) {
                    readyCallbacks.forEach(function(func) { func(); });
                }
            };

            /* Set the initial cache value to false, this will change when
             * the image's onload event handler is called. Finally, point
             * the image's src attribute to the passed in URL.
             */
            resourceCache[url] = false;
            img.src = url;
        }
    }

    /* This is used by developers to grab references to images they know
     * have been previously loaded. If an image is cached, this functions
     * the same as calling load() on that URL.
     */
    function get(url) {
        return resourceCache[url];
    }

    /* This function determines if all of the images that have been requested
     * for loading have in fact been properly loaded.
     */
    function isReady() {
        var ready = true;
        for(var k in resourceCache) {
            if(resourceCache.hasOwnProperty(k) &&
               !resourceCache[k]) {
                ready = false;
            }
        }
        return ready;
    }

    /* This function will add a function to the callback stack that is called
     * when all requested images are properly loaded.
     */
    function onReady(func) {
        readyCallbacks.push(func);
    }

    /* This object defines the publicly accessible functions available to
     * developers by creating a global Resources object.
     */
    window.Resources = {
        load: load,
        get: get,
        onReady: onReady,
        isReady: isReady
    };
})();

const modalC = document.getElementById('c-modal'),
	modalWin = document.getElementById('win-modal'),
	modalGameOver = document.getElementById('game-over-modal'),
	modalBtnWin = document.getElementById('modal-btn-win'),
	modalBtnC = document.getElementById('modal-btn-c');
var characters = modalC.getElementsByClassName('modal__character'),
	isCharSelected = true,
heartN1 = document.getElementById('heart1'),
	heartN2 = document.getElementById('heart2'),
	heartN3 = document.getElementById('heart3');

/*
	-------------------------------------------ENEMY CLASS
*/

// Enemies our player must avoid
var Enemy = function (x, y) {
	// Variables applied to each of our instances go here,
	// we've provided one for you to get started

	// Set enemy location
	this.x = -120;

	// Set enemy initial location
	this.y = 60;

	// set width and height: to use in Enemy.handleCollision() method 
	this.width = 80;
	this.height = 40;

	// Set enemy initial speed
	this.speed = 250; // low
	this.speed = 400; // medium
	this.speed = 500; // high

	// The image/sprite for our enemies, this uses a helper we've provided to easily load images
	this.sprite = 'images/enemy-bug.png';
};

// Update the enemy's position, required method for game
// Parameter: dt, a time delta between ticks
Enemy.prototype.update = function (dt) {

	// Calculate random number between 1 and 3
	let randomN = Math.floor((Math.random() * 3) + 1);

	// When enemy is off-screen
	// randomize new position at which it's created
	if (this.x > 520) {

		// Reset x coordinate to off-screen
		// left side
		this.x = -120;

		// Generate enemy on one of the stone rows
		if (randomN === 1) {
			this.y = 60;
			this.speed = 500;
		} else if (randomN === 2) {
			this.y = 140;
			this.speed = 600;
		} else if (randomN === 3) {
			this.y = 230;
			this.speed = 700;
		}
	}

	this.x += (this.speed * dt);

};

// Draw the enemy on the screen, required method for game
Enemy.prototype.render = function () {
	ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
};

/* 
 * Parameter: check if enemy and player collide.
 * If so, reset player to its initial location
 */
Enemy.prototype.handleCollisions = function () {

	if (this.x < player.x + player.width &&
		this.x + this.width > player.x &&
		this.y < player.y + player.height &&
		this.y + this.height > player.y) {

		// Handle lives 
		if (player.lives === 3) {
			player.loseLife(player.life1);
		} else if (player.lives === 2) {
			player.loseLife(player.life2);
		} else {
			// Handle Game Over
			player.isGameOver = true;
			setTimeout(function () {
				player.endGame();
			}, 1000);
		}
	}
}


/*
	----------------------------------------------PLAYER CLASS
 */

// Player class
var Player = function () {

	// Set initial location
	this.x = 200;
	this.y = 400;

	this.width = 80;
	this.height = 40;

	// Set initial speed
	this.speed;
	
	// Boolean: to use in Player.handleInput() method
	this.isKeyUp = true;

	// Set player directon. Empty.
	// It changes in player.handleInput() to give direction to movement
	this.direction = '';

	// Set player character
	this.sprite = 'images/char-boy.png';

	// Set player initial lives number
	this.lives = 3;

	// Assign hearts elements to three variables. To use in player.loseLife() method
	this.life1 = heartN1;
	this.life2 = heartN2;
	this.life3 = heartN3;

	// Boolean. Use it to check if game is over 
	this.isGameOver = false;
}

// Updates player position
Player.prototype.update = function (dt) {

	if (this.direction === 'right') {
		this.x += (this.speed * dt);
		this.speed = 0;
	} else if (this.direction === 'left') {
		this.x -= (this.speed * dt);
		this.speed = 0;
	} else if (this.direction === 'up') {
		this.y -= (this.speed * dt);
		this.speed = 0;
	} else if (this.direction === 'down') {
		this.y += (this.speed * dt);
		this.speed = 0;
	}

}

/* Player handleInput() method:
 * based on key input sets direction, speed
 * and checks win conditions
*/
Player.prototype.handleInput = function (key) {

	// handle direction and speed of movement
	if (key === 'right' && this.isKeyUp && this.x < 380) {
		this.direction = 'right';
		this.speed = 4000;
	} else if (key === 'left' && this.isKeyUp && this.x > 33) {
		this.direction = 'left';
		this.speed = 4000;
	} else if (key === 'up' && this.isKeyUp && this.y > 45) {
		this.direction = 'up';
		this.speed = 3100;
	} else if (key === 'up' && this.isKeyUp && this.y < 45) {
		// Player wins
		player.winGame();
	} else if (key === 'down' && this.isKeyUp && this.y < 400) {
		this.direction = 'down';
		this.speed = 3100;
	}
}

// Player render() method: draws player character on the screen
Player.prototype.render = function () {
	ctx.drawImage(Resources.get(this.sprite), this.x, this.y);
}

/* Player method: 
 * at collision decrease lives by 1
 * hide a heart
 */ 
Player.prototype.loseLife = function (life) {
	player.lives--;
	life.style.display = 'none';
	player.x = 200;
	player.y = 400;
}

/*
 * Invoked when player wins the game:
 * displays win modal
 * reloads page if player hits enter or clicks on modal button
*/
Player.prototype.winGame = function () {
	modalWin.style.display = 'block';

	document.addEventListener('keydown', function (e) {
		if (e.keyCode === 13) {
			reloadAfterWin();
		}
	})

	modalBtnWin.addEventListener('click', function () {
		reloadAfterWin();
	})
}

/* Player method: 
 * show game over modal
 + reset game on spacebar press
*/ 
Player.prototype.endGame = function () {
	player.isGameOver = true;
	modalGameOver.style.display = 'block';
	document.addEventListener('keydown', function (e) {
		if (e.keyCode === 32 || e.keyCode === 13) {
			isCharSelected = false;
			window.location.reload(false);
		}
	})

}

// Instantiate player object
var player = new Player();

// Instantiate enemy objects
var enemy0 = new Enemy();
var enemy1 = new Enemy();
var enemy2 = new Enemy();

// Instantiate allEnemies object
var allEnemies = [];

// Push enemies into allEnemies[]
allEnemies.push(enemy0, enemy1, enemy2);

/*
 * when player wins it sets isCharSelected to false
 * and reloads the page
*/
function reloadAfterWin() {
	isCharSelected = false;
	window.location.reload(false);
}


// This listens for key presses and sends the keys to your
document.addEventListener('keyup', function (e) {
	var allowedKeys = {
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down'
	};

	player.isKeyUp = true;

	player.handleInput(allowedKeys[e.keyCode]);

});

/*
 * Iterate through DOM character div containers
 * When user clicks a character:
 * if other characters have class 'selected', remove it abd sets isCharSelected to false
 * add class 'selected' to clicked character
 * set isCharSelected to true
 * based on character's id, set player.sprite to related image url
 */
for (let character of characters) {
	character.addEventListener('click', function (e) {

		for (let character of characters) {
			character.classList.remove('selected');
			isCharSelected = false;
		}

		this.classList.add('selected');

		isCharSelected = true;

		if (e.target.id === 'boy') {
			player.sprite = 'images/char-boy.png';
		} else if (e.target.id === 'cat-girl') {
			player.sprite = 'images/char-cat-girl.png';
		} else if (e.target.id === 'horn-girl') {
			player.sprite = 'images/char-horn-girl.png';
		} else if (e.target.id === 'pink-girl') {
			player.sprite = 'images/char-pink-girl.png';
		} else {
			player.sprite = 'images/char-princess-girl.png';
		}
	})
}

/*
 * On character modal. If and when user clicks the button:
 * if no character was selected, don't do anything
 * else hide modal
 */
modalBtnC.addEventListener('click', function () {
	if (isCharSelected == false) {
		return;
	}
	modalC.style.display = 'none';
})

/* Engine.js
 * This file provides the game loop functionality (update entities and render),
 * draws the initial game board on the screen, and then calls the update and
 * render methods on your player and enemy objects (defined in your app.js).
 *
 * A game engine works by drawing the entire game screen over and over, kind of
 * like a flipbook you may have created as a kid. When your player moves across
 * the screen, it may look like just that image/character is moving or being
 * drawn but that is not the case. What's really happening is the entire "scene"
 * is being drawn over and over, presenting the illusion of animation.
 *
 * This engine makes the canvas' context (ctx) object globally available to make 
 * writing app.js a little simpler to work with.
 */

var Engine = (function (global) {
	/* Predefine the variables we'll be using within this scope,
	 * create the canvas element, grab the 2D context for that canvas
	 * set the canvas elements height/width and add it to the DOM.
	 */
	var doc = global.document,
		win = global.window,
		canvas = doc.createElement('canvas'),
		ctx = canvas.getContext('2d'),
		lastTime;

	canvas.width = 505;
	canvas.height = 606;
	doc.body.appendChild(canvas);

	/* This function serves as the kickoff point for the game loop itself
	 * and handles properly calling the update and render methods.
	 */
	function main() {
		/* Get our time delta information which is required if your game
		 * requires smooth animation. Because everyone's computer processes
		 * instructions at different speeds we need a constant value that
		 * would be the same for everyone (regardless of how fast their
		 * computer is) - hurray time!
		 */

		var now = Date.now(),
			dt = (now - lastTime) / 1000.0,
			sprite = "";

		/* Call our update/render functions, pass along the time delta to
		 * our update function since it may be used for smooth animation.
		 */
		if (player.isGameOver == false) {
			update(dt);
		}
		render();

		/* Set our lastTime variable which is used to determine the time delta
		 * for the next time this function is called.
		 */
		lastTime = now;

		/* Use the browser's requestAnimationFrame function to call this
		 * function again as soon as the browser is able to draw another frame.
		 */
		if (player.isGameOver == false) {
			win.requestAnimationFrame(main);
		}
	}

	/* This function does some initial setup that should only occur once,
	 * particularly setting the lastTime variable that is required for the
	 * game loop.
	 */
	function init() {
		lastTime = Date.now();
		main();
		//reset();
	}

	/* This function is called by main (our game loop) and itself calls all
	 * of the functions which may need to update entity's data. Based on how
	 * you implement your collision detection (when two entities occupy the
	 * same space, for instance when your character should die), you may find
	 * the need to add an additional function call here. For now, we've left
	 * it commented out - you may or may not want to implement this
	 * functionality this way (you could just implement collision detection
	 * on the entities themselves within your app.js file).
	 */
	function update(dt) {
		updateEntities(dt);
		checkCollisions();
	}

	/* This is called by the update function and loops through all of the
	 * objects within your allEnemies array as defined in app.js and calls
	 * their update() methods. It will then call the update function for your
	 * player object. These update methods should focus purely on updating
	 * the data/properties related to the object. Do your drawing in your
	 * render methods.
	 */
	function updateEntities(dt) {
		allEnemies.forEach(function (enemy) {
			enemy.update(dt);
		});
		player.update(dt);
	}


	/* This checks for collisions between an enemy and player
	 * Since entities are on axes and have width and height
	 * it's possible to check for gaps between them. 
	 * If that's the case then a collision happend,
	 * and the player goes back to its initial position.
	 */
	function checkCollisions() {
		allEnemies.forEach(function (enemy) {
			enemy.handleCollisions();
		})
	}

	/* This function initially draws the "game level", it will then call
	 * the renderEntities function. Remember, this function is called every
	 * game tick (or loop of the game engine) because that's how games work -
	 * they are flipbooks creating the illusion of animation but in reality
	 * they are just drawing the entire screen over and over.
	 */

	function render() {
		/* This array holds the relative URL to the image used
		 * for that particular row of the game level.
		 */
		var rowImages = [
                'images/water-block.png', // Top row is water
                'images/stone-block.png', // Row 1 of 3 of stone
                'images/stone-block.png', // Row 2 of 3 of stone
                'images/stone-block.png', // Row 3 of 3 of stone
                'images/grass-block.png', // Row 1 of 2 of grass
                'images/grass-block.png' // Row 2 of 2 of grass
            ],
			numRows = 6,
			numCols = 5,
			row, col;

		// Before drawing, clear existing canvas
		ctx.clearRect(0, 0, canvas.width, canvas.height)

		/* Loop through the number of rows and columns we've defined above
		 * and, using the rowImages array, draw the correct image for that
		 * portion of the "grid"
		 */
		for (row = 0; row < numRows; row++) {
			for (col = 0; col < numCols; col++) {
				/* The drawImage function of the canvas' context element
				 * requires 3 parameters: the image to draw, the x coordinate
				 * to start drawing and the y coordinate to start drawing.
				 * We're using our Resources helpers to refer to our images
				 * so that we get the benefits of caching these images, since
				 * we're using them over and over.
				 */
				ctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);
			}
		}

		renderEntities();
	}

	/* This function is called by the render function and is called on each game
	 * tick. Its purpose is to then call the render functions you have defined
	 * on your enemy and player entities within app.js
	 */
	function renderEntities() {
		/* Loop through all of the objects within the allEnemies array and call
		 * the render function you have defined.
		 */
		allEnemies.forEach(function (enemy) {
			enemy.render();
		});
		player.render();
	}

	/* This function does nothing but it could have been a good place to
	 * handle game reset states - maybe a new game menu or a game over screen
	 * those sorts of things. It's only called once by the init() method.
	 */
	// function reset(){}

	/* Go ahead and load all of the images we know we're going to need to
	 * draw our game level. Then set init as the callback method, so that when
	 * all of these images are properly loaded our game will start.
	 */

	Resources.load([
        'images/stone-block.png',
        'images/water-block.png',
        'images/grass-block.png',
        'images/enemy-bug.png',
        'images/char-boy.png',
		'images/char-cat-girl.png',
		'images/char-horn-girl.png',
		'images/char-pink-girl.png',
		'images/char-princess-girl.png'
	]);
	Resources.onReady(init);

	/* Assign the canvas' context object to the global variable (the window
	 * object when run in a browser) so that developers can use it more easily
	 * from within their app.js files.
	 */
	global.ctx = ctx;
})(this);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJqcy9hbGwubWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIiAgICAvKiBSZXNvdXJjZXMuanNcbiAqIFRoaXMgaXMgc2ltcGx5IGFuIGltYWdlIGxvYWRpbmcgdXRpbGl0eS4gSXQgZWFzZXMgdGhlIHByb2Nlc3Mgb2YgbG9hZGluZ1xuICogaW1hZ2UgZmlsZXMgc28gdGhhdCB0aGV5IGNhbiBiZSB1c2VkIHdpdGhpbiB5b3VyIGdhbWUuIEl0IGFsc28gaW5jbHVkZXNcbiAqIGEgc2ltcGxlIFwiY2FjaGluZ1wiIGxheWVyIHNvIGl0IHdpbGwgcmV1c2UgY2FjaGVkIGltYWdlcyBpZiB5b3UgYXR0ZW1wdFxuICogdG8gbG9hZCB0aGUgc2FtZSBpbWFnZSBtdWx0aXBsZSB0aW1lcy5cbiAqL1xuKGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNvdXJjZUNhY2hlID0ge307XG4gICAgdmFyIGxvYWRpbmcgPSBbXTtcbiAgICB2YXIgcmVhZHlDYWxsYmFja3MgPSBbXTtcblxuICAgIC8qIFRoaXMgaXMgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgaW1hZ2UgbG9hZGluZyBmdW5jdGlvbi4gSXQgYWNjZXB0c1xuICAgICAqIGFuIGFycmF5IG9mIHN0cmluZ3MgcG9pbnRpbmcgdG8gaW1hZ2UgZmlsZXMgb3IgYSBzdHJpbmcgZm9yIGEgc2luZ2xlXG4gICAgICogaW1hZ2UuIEl0IHdpbGwgdGhlbiBjYWxsIG91ciBwcml2YXRlIGltYWdlIGxvYWRpbmcgZnVuY3Rpb24gYWNjb3JkaW5nbHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbG9hZCh1cmxPckFycikge1xuICAgICAgICBpZih1cmxPckFyciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAvKiBJZiB0aGUgZGV2ZWxvcGVyIHBhc3NlZCBpbiBhbiBhcnJheSBvZiBpbWFnZXNcbiAgICAgICAgICAgICAqIGxvb3AgdGhyb3VnaCBlYWNoIHZhbHVlIGFuZCBjYWxsIG91ciBpbWFnZVxuICAgICAgICAgICAgICogbG9hZGVyIG9uIHRoYXQgaW1hZ2UgZmlsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cmxPckFyci5mb3JFYWNoKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICAgICAgICAgIF9sb2FkKHVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIFRoZSBkZXZlbG9wZXIgZGlkIG5vdCBwYXNzIGFuIGFycmF5IHRvIHRoaXMgZnVuY3Rpb24sXG4gICAgICAgICAgICAgKiBhc3N1bWUgdGhlIHZhbHVlIGlzIGEgc3RyaW5nIGFuZCBjYWxsIG91ciBpbWFnZSBsb2FkZXJcbiAgICAgICAgICAgICAqIGRpcmVjdGx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfbG9hZCh1cmxPckFycik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBUaGlzIGlzIG91ciBwcml2YXRlIGltYWdlIGxvYWRlciBmdW5jdGlvbiwgaXQgaXNcbiAgICAgKiBjYWxsZWQgYnkgdGhlIHB1YmxpYyBpbWFnZSBsb2FkZXIgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gX2xvYWQodXJsKSB7XG4gICAgICAgIGlmKHJlc291cmNlQ2FjaGVbdXJsXSkge1xuICAgICAgICAgICAgLyogSWYgdGhpcyBVUkwgaGFzIGJlZW4gcHJldmlvdXNseSBsb2FkZWQgaXQgd2lsbCBleGlzdCB3aXRoaW5cbiAgICAgICAgICAgICAqIG91ciByZXNvdXJjZUNhY2hlIGFycmF5LiBKdXN0IHJldHVybiB0aGF0IGltYWdlIHJhdGhlclxuICAgICAgICAgICAgICogcmUtbG9hZGluZyB0aGUgaW1hZ2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBUaGlzIFVSTCBoYXMgbm90IGJlZW4gcHJldmlvdXNseSBsb2FkZWQgYW5kIGlzIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgKiB3aXRoaW4gb3VyIGNhY2hlOyB3ZSdsbCBuZWVkIHRvIGxvYWQgdGhpcyBpbWFnZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8qIE9uY2Ugb3VyIGltYWdlIGhhcyBwcm9wZXJseSBsb2FkZWQsIGFkZCBpdCB0byBvdXIgY2FjaGVcbiAgICAgICAgICAgICAgICAgKiBzbyB0aGF0IHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoaXMgaW1hZ2UgaWYgdGhlIGRldmVsb3BlclxuICAgICAgICAgICAgICAgICAqIGF0dGVtcHRzIHRvIGxvYWQgdGhpcyBmaWxlIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VDYWNoZVt1cmxdID0gaW1nO1xuXG4gICAgICAgICAgICAgICAgLyogT25jZSB0aGUgaW1hZ2UgaXMgYWN0dWFsbHkgbG9hZGVkIGFuZCBwcm9wZXJseSBjYWNoZWQsXG4gICAgICAgICAgICAgICAgICogY2FsbCBhbGwgb2YgdGhlIG9uUmVhZHkoKSBjYWxsYmFja3Mgd2UgaGF2ZSBkZWZpbmVkLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmKGlzUmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKiBTZXQgdGhlIGluaXRpYWwgY2FjaGUgdmFsdWUgdG8gZmFsc2UsIHRoaXMgd2lsbCBjaGFuZ2Ugd2hlblxuICAgICAgICAgICAgICogdGhlIGltYWdlJ3Mgb25sb2FkIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLiBGaW5hbGx5LCBwb2ludFxuICAgICAgICAgICAgICogdGhlIGltYWdlJ3Mgc3JjIGF0dHJpYnV0ZSB0byB0aGUgcGFzc2VkIGluIFVSTC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVzb3VyY2VDYWNoZVt1cmxdID0gZmFsc2U7XG4gICAgICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogVGhpcyBpcyB1c2VkIGJ5IGRldmVsb3BlcnMgdG8gZ3JhYiByZWZlcmVuY2VzIHRvIGltYWdlcyB0aGV5IGtub3dcbiAgICAgKiBoYXZlIGJlZW4gcHJldmlvdXNseSBsb2FkZWQuIElmIGFuIGltYWdlIGlzIGNhY2hlZCwgdGhpcyBmdW5jdGlvbnNcbiAgICAgKiB0aGUgc2FtZSBhcyBjYWxsaW5nIGxvYWQoKSBvbiB0aGF0IFVSTC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQodXJsKSB7XG4gICAgICAgIHJldHVybiByZXNvdXJjZUNhY2hlW3VybF07XG4gICAgfVxuXG4gICAgLyogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIGFsbCBvZiB0aGUgaW1hZ2VzIHRoYXQgaGF2ZSBiZWVuIHJlcXVlc3RlZFxuICAgICAqIGZvciBsb2FkaW5nIGhhdmUgaW4gZmFjdCBiZWVuIHByb3Blcmx5IGxvYWRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1JlYWR5KCkge1xuICAgICAgICB2YXIgcmVhZHkgPSB0cnVlO1xuICAgICAgICBmb3IodmFyIGsgaW4gcmVzb3VyY2VDYWNoZSkge1xuICAgICAgICAgICAgaWYocmVzb3VyY2VDYWNoZS5oYXNPd25Qcm9wZXJ0eShrKSAmJlxuICAgICAgICAgICAgICAgIXJlc291cmNlQ2FjaGVba10pIHtcbiAgICAgICAgICAgICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkeTtcbiAgICB9XG5cbiAgICAvKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWRkIGEgZnVuY3Rpb24gdG8gdGhlIGNhbGxiYWNrIHN0YWNrIHRoYXQgaXMgY2FsbGVkXG4gICAgICogd2hlbiBhbGwgcmVxdWVzdGVkIGltYWdlcyBhcmUgcHJvcGVybHkgbG9hZGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUmVhZHkoZnVuYykge1xuICAgICAgICByZWFkeUNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICAgIH1cblxuICAgIC8qIFRoaXMgb2JqZWN0IGRlZmluZXMgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgZnVuY3Rpb25zIGF2YWlsYWJsZSB0b1xuICAgICAqIGRldmVsb3BlcnMgYnkgY3JlYXRpbmcgYSBnbG9iYWwgUmVzb3VyY2VzIG9iamVjdC5cbiAgICAgKi9cbiAgICB3aW5kb3cuUmVzb3VyY2VzID0ge1xuICAgICAgICBsb2FkOiBsb2FkLFxuICAgICAgICBnZXQ6IGdldCxcbiAgICAgICAgb25SZWFkeTogb25SZWFkeSxcbiAgICAgICAgaXNSZWFkeTogaXNSZWFkeVxuICAgIH07XG59KSgpO1xuXG5jb25zdCBtb2RhbEMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYy1tb2RhbCcpLFxuXHRtb2RhbFdpbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aW4tbW9kYWwnKSxcblx0bW9kYWxHYW1lT3ZlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYW1lLW92ZXItbW9kYWwnKSxcblx0bW9kYWxCdG5XaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwtYnRuLXdpbicpLFxuXHRtb2RhbEJ0bkMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9kYWwtYnRuLWMnKTtcbnZhciBjaGFyYWN0ZXJzID0gbW9kYWxDLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ21vZGFsX19jaGFyYWN0ZXInKSxcblx0aXNDaGFyU2VsZWN0ZWQgPSB0cnVlLFxuaGVhcnROMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFydDEnKSxcblx0aGVhcnROMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFydDInKSxcblx0aGVhcnROMyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWFydDMnKTtcblxuLypcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLUVORU1ZIENMQVNTXG4qL1xuXG4vLyBFbmVtaWVzIG91ciBwbGF5ZXIgbXVzdCBhdm9pZFxudmFyIEVuZW15ID0gZnVuY3Rpb24gKHgsIHkpIHtcblx0Ly8gVmFyaWFibGVzIGFwcGxpZWQgdG8gZWFjaCBvZiBvdXIgaW5zdGFuY2VzIGdvIGhlcmUsXG5cdC8vIHdlJ3ZlIHByb3ZpZGVkIG9uZSBmb3IgeW91IHRvIGdldCBzdGFydGVkXG5cblx0Ly8gU2V0IGVuZW15IGxvY2F0aW9uXG5cdHRoaXMueCA9IC0xMjA7XG5cblx0Ly8gU2V0IGVuZW15IGluaXRpYWwgbG9jYXRpb25cblx0dGhpcy55ID0gNjA7XG5cblx0Ly8gc2V0IHdpZHRoIGFuZCBoZWlnaHQ6IHRvIHVzZSBpbiBFbmVteS5oYW5kbGVDb2xsaXNpb24oKSBtZXRob2QgXG5cdHRoaXMud2lkdGggPSA4MDtcblx0dGhpcy5oZWlnaHQgPSA0MDtcblxuXHQvLyBTZXQgZW5lbXkgaW5pdGlhbCBzcGVlZFxuXHR0aGlzLnNwZWVkID0gMjUwOyAvLyBsb3dcblx0dGhpcy5zcGVlZCA9IDQwMDsgLy8gbWVkaXVtXG5cdHRoaXMuc3BlZWQgPSA1MDA7IC8vIGhpZ2hcblxuXHQvLyBUaGUgaW1hZ2Uvc3ByaXRlIGZvciBvdXIgZW5lbWllcywgdGhpcyB1c2VzIGEgaGVscGVyIHdlJ3ZlIHByb3ZpZGVkIHRvIGVhc2lseSBsb2FkIGltYWdlc1xuXHR0aGlzLnNwcml0ZSA9ICdpbWFnZXMvZW5lbXktYnVnLnBuZyc7XG59O1xuXG4vLyBVcGRhdGUgdGhlIGVuZW15J3MgcG9zaXRpb24sIHJlcXVpcmVkIG1ldGhvZCBmb3IgZ2FtZVxuLy8gUGFyYW1ldGVyOiBkdCwgYSB0aW1lIGRlbHRhIGJldHdlZW4gdGlja3NcbkVuZW15LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZHQpIHtcblxuXHQvLyBDYWxjdWxhdGUgcmFuZG9tIG51bWJlciBiZXR3ZWVuIDEgYW5kIDNcblx0bGV0IHJhbmRvbU4gPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogMykgKyAxKTtcblxuXHQvLyBXaGVuIGVuZW15IGlzIG9mZi1zY3JlZW5cblx0Ly8gcmFuZG9taXplIG5ldyBwb3NpdGlvbiBhdCB3aGljaCBpdCdzIGNyZWF0ZWRcblx0aWYgKHRoaXMueCA+IDUyMCkge1xuXG5cdFx0Ly8gUmVzZXQgeCBjb29yZGluYXRlIHRvIG9mZi1zY3JlZW5cblx0XHQvLyBsZWZ0IHNpZGVcblx0XHR0aGlzLnggPSAtMTIwO1xuXG5cdFx0Ly8gR2VuZXJhdGUgZW5lbXkgb24gb25lIG9mIHRoZSBzdG9uZSByb3dzXG5cdFx0aWYgKHJhbmRvbU4gPT09IDEpIHtcblx0XHRcdHRoaXMueSA9IDYwO1xuXHRcdFx0dGhpcy5zcGVlZCA9IDUwMDtcblx0XHR9IGVsc2UgaWYgKHJhbmRvbU4gPT09IDIpIHtcblx0XHRcdHRoaXMueSA9IDE0MDtcblx0XHRcdHRoaXMuc3BlZWQgPSA2MDA7XG5cdFx0fSBlbHNlIGlmIChyYW5kb21OID09PSAzKSB7XG5cdFx0XHR0aGlzLnkgPSAyMzA7XG5cdFx0XHR0aGlzLnNwZWVkID0gNzAwO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMueCArPSAodGhpcy5zcGVlZCAqIGR0KTtcblxufTtcblxuLy8gRHJhdyB0aGUgZW5lbXkgb24gdGhlIHNjcmVlbiwgcmVxdWlyZWQgbWV0aG9kIGZvciBnYW1lXG5FbmVteS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRjdHguZHJhd0ltYWdlKFJlc291cmNlcy5nZXQodGhpcy5zcHJpdGUpLCB0aGlzLngsIHRoaXMueSk7XG59O1xuXG4vKiBcbiAqIFBhcmFtZXRlcjogY2hlY2sgaWYgZW5lbXkgYW5kIHBsYXllciBjb2xsaWRlLlxuICogSWYgc28sIHJlc2V0IHBsYXllciB0byBpdHMgaW5pdGlhbCBsb2NhdGlvblxuICovXG5FbmVteS5wcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuXHRpZiAodGhpcy54IDwgcGxheWVyLnggKyBwbGF5ZXIud2lkdGggJiZcblx0XHR0aGlzLnggKyB0aGlzLndpZHRoID4gcGxheWVyLnggJiZcblx0XHR0aGlzLnkgPCBwbGF5ZXIueSArIHBsYXllci5oZWlnaHQgJiZcblx0XHR0aGlzLnkgKyB0aGlzLmhlaWdodCA+IHBsYXllci55KSB7XG5cblx0XHQvLyBIYW5kbGUgbGl2ZXMgXG5cdFx0aWYgKHBsYXllci5saXZlcyA9PT0gMykge1xuXHRcdFx0cGxheWVyLmxvc2VMaWZlKHBsYXllci5saWZlMSk7XG5cdFx0fSBlbHNlIGlmIChwbGF5ZXIubGl2ZXMgPT09IDIpIHtcblx0XHRcdHBsYXllci5sb3NlTGlmZShwbGF5ZXIubGlmZTIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBIYW5kbGUgR2FtZSBPdmVyXG5cdFx0XHRwbGF5ZXIuaXNHYW1lT3ZlciA9IHRydWU7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cGxheWVyLmVuZEdhbWUoKTtcblx0XHRcdH0sIDEwMDApO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1QTEFZRVIgQ0xBU1NcbiAqL1xuXG4vLyBQbGF5ZXIgY2xhc3NcbnZhciBQbGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG5cblx0Ly8gU2V0IGluaXRpYWwgbG9jYXRpb25cblx0dGhpcy54ID0gMjAwO1xuXHR0aGlzLnkgPSA0MDA7XG5cblx0dGhpcy53aWR0aCA9IDgwO1xuXHR0aGlzLmhlaWdodCA9IDQwO1xuXG5cdC8vIFNldCBpbml0aWFsIHNwZWVkXG5cdHRoaXMuc3BlZWQ7XG5cdFxuXHQvLyBCb29sZWFuOiB0byB1c2UgaW4gUGxheWVyLmhhbmRsZUlucHV0KCkgbWV0aG9kXG5cdHRoaXMuaXNLZXlVcCA9IHRydWU7XG5cblx0Ly8gU2V0IHBsYXllciBkaXJlY3Rvbi4gRW1wdHkuXG5cdC8vIEl0IGNoYW5nZXMgaW4gcGxheWVyLmhhbmRsZUlucHV0KCkgdG8gZ2l2ZSBkaXJlY3Rpb24gdG8gbW92ZW1lbnRcblx0dGhpcy5kaXJlY3Rpb24gPSAnJztcblxuXHQvLyBTZXQgcGxheWVyIGNoYXJhY3RlclxuXHR0aGlzLnNwcml0ZSA9ICdpbWFnZXMvY2hhci1ib3kucG5nJztcblxuXHQvLyBTZXQgcGxheWVyIGluaXRpYWwgbGl2ZXMgbnVtYmVyXG5cdHRoaXMubGl2ZXMgPSAzO1xuXG5cdC8vIEFzc2lnbiBoZWFydHMgZWxlbWVudHMgdG8gdGhyZWUgdmFyaWFibGVzLiBUbyB1c2UgaW4gcGxheWVyLmxvc2VMaWZlKCkgbWV0aG9kXG5cdHRoaXMubGlmZTEgPSBoZWFydE4xO1xuXHR0aGlzLmxpZmUyID0gaGVhcnROMjtcblx0dGhpcy5saWZlMyA9IGhlYXJ0TjM7XG5cblx0Ly8gQm9vbGVhbi4gVXNlIGl0IHRvIGNoZWNrIGlmIGdhbWUgaXMgb3ZlciBcblx0dGhpcy5pc0dhbWVPdmVyID0gZmFsc2U7XG59XG5cbi8vIFVwZGF0ZXMgcGxheWVyIHBvc2l0aW9uXG5QbGF5ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkdCkge1xuXG5cdGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuXHRcdHRoaXMueCArPSAodGhpcy5zcGVlZCAqIGR0KTtcblx0XHR0aGlzLnNwZWVkID0gMDtcblx0fSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG5cdFx0dGhpcy54IC09ICh0aGlzLnNwZWVkICogZHQpO1xuXHRcdHRoaXMuc3BlZWQgPSAwO1xuXHR9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndXAnKSB7XG5cdFx0dGhpcy55IC09ICh0aGlzLnNwZWVkICogZHQpO1xuXHRcdHRoaXMuc3BlZWQgPSAwO1xuXHR9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnZG93bicpIHtcblx0XHR0aGlzLnkgKz0gKHRoaXMuc3BlZWQgKiBkdCk7XG5cdFx0dGhpcy5zcGVlZCA9IDA7XG5cdH1cblxufVxuXG4vKiBQbGF5ZXIgaGFuZGxlSW5wdXQoKSBtZXRob2Q6XG4gKiBiYXNlZCBvbiBrZXkgaW5wdXQgc2V0cyBkaXJlY3Rpb24sIHNwZWVkXG4gKiBhbmQgY2hlY2tzIHdpbiBjb25kaXRpb25zXG4qL1xuUGxheWVyLnByb3RvdHlwZS5oYW5kbGVJbnB1dCA9IGZ1bmN0aW9uIChrZXkpIHtcblxuXHQvLyBoYW5kbGUgZGlyZWN0aW9uIGFuZCBzcGVlZCBvZiBtb3ZlbWVudFxuXHRpZiAoa2V5ID09PSAncmlnaHQnICYmIHRoaXMuaXNLZXlVcCAmJiB0aGlzLnggPCAzODApIHtcblx0XHR0aGlzLmRpcmVjdGlvbiA9ICdyaWdodCc7XG5cdFx0dGhpcy5zcGVlZCA9IDQwMDA7XG5cdH0gZWxzZSBpZiAoa2V5ID09PSAnbGVmdCcgJiYgdGhpcy5pc0tleVVwICYmIHRoaXMueCA+IDMzKSB7XG5cdFx0dGhpcy5kaXJlY3Rpb24gPSAnbGVmdCc7XG5cdFx0dGhpcy5zcGVlZCA9IDQwMDA7XG5cdH0gZWxzZSBpZiAoa2V5ID09PSAndXAnICYmIHRoaXMuaXNLZXlVcCAmJiB0aGlzLnkgPiA0NSkge1xuXHRcdHRoaXMuZGlyZWN0aW9uID0gJ3VwJztcblx0XHR0aGlzLnNwZWVkID0gMzEwMDtcblx0fSBlbHNlIGlmIChrZXkgPT09ICd1cCcgJiYgdGhpcy5pc0tleVVwICYmIHRoaXMueSA8IDQ1KSB7XG5cdFx0Ly8gUGxheWVyIHdpbnNcblx0XHRwbGF5ZXIud2luR2FtZSgpO1xuXHR9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nICYmIHRoaXMuaXNLZXlVcCAmJiB0aGlzLnkgPCA0MDApIHtcblx0XHR0aGlzLmRpcmVjdGlvbiA9ICdkb3duJztcblx0XHR0aGlzLnNwZWVkID0gMzEwMDtcblx0fVxufVxuXG4vLyBQbGF5ZXIgcmVuZGVyKCkgbWV0aG9kOiBkcmF3cyBwbGF5ZXIgY2hhcmFjdGVyIG9uIHRoZSBzY3JlZW5cblBsYXllci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRjdHguZHJhd0ltYWdlKFJlc291cmNlcy5nZXQodGhpcy5zcHJpdGUpLCB0aGlzLngsIHRoaXMueSk7XG59XG5cbi8qIFBsYXllciBtZXRob2Q6IFxuICogYXQgY29sbGlzaW9uIGRlY3JlYXNlIGxpdmVzIGJ5IDFcbiAqIGhpZGUgYSBoZWFydFxuICovIFxuUGxheWVyLnByb3RvdHlwZS5sb3NlTGlmZSA9IGZ1bmN0aW9uIChsaWZlKSB7XG5cdHBsYXllci5saXZlcy0tO1xuXHRsaWZlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdHBsYXllci54ID0gMjAwO1xuXHRwbGF5ZXIueSA9IDQwMDtcbn1cblxuLypcbiAqIEludm9rZWQgd2hlbiBwbGF5ZXIgd2lucyB0aGUgZ2FtZTpcbiAqIGRpc3BsYXlzIHdpbiBtb2RhbFxuICogcmVsb2FkcyBwYWdlIGlmIHBsYXllciBoaXRzIGVudGVyIG9yIGNsaWNrcyBvbiBtb2RhbCBidXR0b25cbiovXG5QbGF5ZXIucHJvdG90eXBlLndpbkdhbWUgPSBmdW5jdGlvbiAoKSB7XG5cdG1vZGFsV2luLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChlLmtleUNvZGUgPT09IDEzKSB7XG5cdFx0XHRyZWxvYWRBZnRlcldpbigpO1xuXHRcdH1cblx0fSlcblxuXHRtb2RhbEJ0bldpbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRyZWxvYWRBZnRlcldpbigpO1xuXHR9KVxufVxuXG4vKiBQbGF5ZXIgbWV0aG9kOiBcbiAqIHNob3cgZ2FtZSBvdmVyIG1vZGFsXG4gKyByZXNldCBnYW1lIG9uIHNwYWNlYmFyIHByZXNzXG4qLyBcblBsYXllci5wcm90b3R5cGUuZW5kR2FtZSA9IGZ1bmN0aW9uICgpIHtcblx0cGxheWVyLmlzR2FtZU92ZXIgPSB0cnVlO1xuXHRtb2RhbEdhbWVPdmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAoZS5rZXlDb2RlID09PSAzMiB8fCBlLmtleUNvZGUgPT09IDEzKSB7XG5cdFx0XHRpc0NoYXJTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0d2luZG93LmxvY2F0aW9uLnJlbG9hZChmYWxzZSk7XG5cdFx0fVxuXHR9KVxuXG59XG5cbi8vIEluc3RhbnRpYXRlIHBsYXllciBvYmplY3RcbnZhciBwbGF5ZXIgPSBuZXcgUGxheWVyKCk7XG5cbi8vIEluc3RhbnRpYXRlIGVuZW15IG9iamVjdHNcbnZhciBlbmVteTAgPSBuZXcgRW5lbXkoKTtcbnZhciBlbmVteTEgPSBuZXcgRW5lbXkoKTtcbnZhciBlbmVteTIgPSBuZXcgRW5lbXkoKTtcblxuLy8gSW5zdGFudGlhdGUgYWxsRW5lbWllcyBvYmplY3RcbnZhciBhbGxFbmVtaWVzID0gW107XG5cbi8vIFB1c2ggZW5lbWllcyBpbnRvIGFsbEVuZW1pZXNbXVxuYWxsRW5lbWllcy5wdXNoKGVuZW15MCwgZW5lbXkxLCBlbmVteTIpO1xuXG4vKlxuICogd2hlbiBwbGF5ZXIgd2lucyBpdCBzZXRzIGlzQ2hhclNlbGVjdGVkIHRvIGZhbHNlXG4gKiBhbmQgcmVsb2FkcyB0aGUgcGFnZVxuKi9cbmZ1bmN0aW9uIHJlbG9hZEFmdGVyV2luKCkge1xuXHRpc0NoYXJTZWxlY3RlZCA9IGZhbHNlO1xuXHR3aW5kb3cubG9jYXRpb24ucmVsb2FkKGZhbHNlKTtcbn1cblxuXG4vLyBUaGlzIGxpc3RlbnMgZm9yIGtleSBwcmVzc2VzIGFuZCBzZW5kcyB0aGUga2V5cyB0byB5b3VyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG5cdHZhciBhbGxvd2VkS2V5cyA9IHtcblx0XHQzNzogJ2xlZnQnLFxuXHRcdDM4OiAndXAnLFxuXHRcdDM5OiAncmlnaHQnLFxuXHRcdDQwOiAnZG93bidcblx0fTtcblxuXHRwbGF5ZXIuaXNLZXlVcCA9IHRydWU7XG5cblx0cGxheWVyLmhhbmRsZUlucHV0KGFsbG93ZWRLZXlzW2Uua2V5Q29kZV0pO1xuXG59KTtcblxuLypcbiAqIEl0ZXJhdGUgdGhyb3VnaCBET00gY2hhcmFjdGVyIGRpdiBjb250YWluZXJzXG4gKiBXaGVuIHVzZXIgY2xpY2tzIGEgY2hhcmFjdGVyOlxuICogaWYgb3RoZXIgY2hhcmFjdGVycyBoYXZlIGNsYXNzICdzZWxlY3RlZCcsIHJlbW92ZSBpdCBhYmQgc2V0cyBpc0NoYXJTZWxlY3RlZCB0byBmYWxzZVxuICogYWRkIGNsYXNzICdzZWxlY3RlZCcgdG8gY2xpY2tlZCBjaGFyYWN0ZXJcbiAqIHNldCBpc0NoYXJTZWxlY3RlZCB0byB0cnVlXG4gKiBiYXNlZCBvbiBjaGFyYWN0ZXIncyBpZCwgc2V0IHBsYXllci5zcHJpdGUgdG8gcmVsYXRlZCBpbWFnZSB1cmxcbiAqL1xuZm9yIChsZXQgY2hhcmFjdGVyIG9mIGNoYXJhY3RlcnMpIHtcblx0Y2hhcmFjdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcblxuXHRcdGZvciAobGV0IGNoYXJhY3RlciBvZiBjaGFyYWN0ZXJzKSB7XG5cdFx0XHRjaGFyYWN0ZXIuY2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTtcblx0XHRcdGlzQ2hhclNlbGVjdGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuXG5cdFx0aXNDaGFyU2VsZWN0ZWQgPSB0cnVlO1xuXG5cdFx0aWYgKGUudGFyZ2V0LmlkID09PSAnYm95Jykge1xuXHRcdFx0cGxheWVyLnNwcml0ZSA9ICdpbWFnZXMvY2hhci1ib3kucG5nJztcblx0XHR9IGVsc2UgaWYgKGUudGFyZ2V0LmlkID09PSAnY2F0LWdpcmwnKSB7XG5cdFx0XHRwbGF5ZXIuc3ByaXRlID0gJ2ltYWdlcy9jaGFyLWNhdC1naXJsLnBuZyc7XG5cdFx0fSBlbHNlIGlmIChlLnRhcmdldC5pZCA9PT0gJ2hvcm4tZ2lybCcpIHtcblx0XHRcdHBsYXllci5zcHJpdGUgPSAnaW1hZ2VzL2NoYXItaG9ybi1naXJsLnBuZyc7XG5cdFx0fSBlbHNlIGlmIChlLnRhcmdldC5pZCA9PT0gJ3BpbmstZ2lybCcpIHtcblx0XHRcdHBsYXllci5zcHJpdGUgPSAnaW1hZ2VzL2NoYXItcGluay1naXJsLnBuZyc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBsYXllci5zcHJpdGUgPSAnaW1hZ2VzL2NoYXItcHJpbmNlc3MtZ2lybC5wbmcnO1xuXHRcdH1cblx0fSlcbn1cblxuLypcbiAqIE9uIGNoYXJhY3RlciBtb2RhbC4gSWYgYW5kIHdoZW4gdXNlciBjbGlja3MgdGhlIGJ1dHRvbjpcbiAqIGlmIG5vIGNoYXJhY3RlciB3YXMgc2VsZWN0ZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gKiBlbHNlIGhpZGUgbW9kYWxcbiAqL1xubW9kYWxCdG5DLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRpZiAoaXNDaGFyU2VsZWN0ZWQgPT0gZmFsc2UpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0bW9kYWxDLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59KVxuXG4vKiBFbmdpbmUuanNcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyB0aGUgZ2FtZSBsb29wIGZ1bmN0aW9uYWxpdHkgKHVwZGF0ZSBlbnRpdGllcyBhbmQgcmVuZGVyKSxcbiAqIGRyYXdzIHRoZSBpbml0aWFsIGdhbWUgYm9hcmQgb24gdGhlIHNjcmVlbiwgYW5kIHRoZW4gY2FsbHMgdGhlIHVwZGF0ZSBhbmRcbiAqIHJlbmRlciBtZXRob2RzIG9uIHlvdXIgcGxheWVyIGFuZCBlbmVteSBvYmplY3RzIChkZWZpbmVkIGluIHlvdXIgYXBwLmpzKS5cbiAqXG4gKiBBIGdhbWUgZW5naW5lIHdvcmtzIGJ5IGRyYXdpbmcgdGhlIGVudGlyZSBnYW1lIHNjcmVlbiBvdmVyIGFuZCBvdmVyLCBraW5kIG9mXG4gKiBsaWtlIGEgZmxpcGJvb2sgeW91IG1heSBoYXZlIGNyZWF0ZWQgYXMgYSBraWQuIFdoZW4geW91ciBwbGF5ZXIgbW92ZXMgYWNyb3NzXG4gKiB0aGUgc2NyZWVuLCBpdCBtYXkgbG9vayBsaWtlIGp1c3QgdGhhdCBpbWFnZS9jaGFyYWN0ZXIgaXMgbW92aW5nIG9yIGJlaW5nXG4gKiBkcmF3biBidXQgdGhhdCBpcyBub3QgdGhlIGNhc2UuIFdoYXQncyByZWFsbHkgaGFwcGVuaW5nIGlzIHRoZSBlbnRpcmUgXCJzY2VuZVwiXG4gKiBpcyBiZWluZyBkcmF3biBvdmVyIGFuZCBvdmVyLCBwcmVzZW50aW5nIHRoZSBpbGx1c2lvbiBvZiBhbmltYXRpb24uXG4gKlxuICogVGhpcyBlbmdpbmUgbWFrZXMgdGhlIGNhbnZhcycgY29udGV4dCAoY3R4KSBvYmplY3QgZ2xvYmFsbHkgYXZhaWxhYmxlIHRvIG1ha2UgXG4gKiB3cml0aW5nIGFwcC5qcyBhIGxpdHRsZSBzaW1wbGVyIHRvIHdvcmsgd2l0aC5cbiAqL1xuXG52YXIgRW5naW5lID0gKGZ1bmN0aW9uIChnbG9iYWwpIHtcblx0LyogUHJlZGVmaW5lIHRoZSB2YXJpYWJsZXMgd2UnbGwgYmUgdXNpbmcgd2l0aGluIHRoaXMgc2NvcGUsXG5cdCAqIGNyZWF0ZSB0aGUgY2FudmFzIGVsZW1lbnQsIGdyYWIgdGhlIDJEIGNvbnRleHQgZm9yIHRoYXQgY2FudmFzXG5cdCAqIHNldCB0aGUgY2FudmFzIGVsZW1lbnRzIGhlaWdodC93aWR0aCBhbmQgYWRkIGl0IHRvIHRoZSBET00uXG5cdCAqL1xuXHR2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50LFxuXHRcdHdpbiA9IGdsb2JhbC53aW5kb3csXG5cdFx0Y2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuXHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuXHRcdGxhc3RUaW1lO1xuXG5cdGNhbnZhcy53aWR0aCA9IDUwNTtcblx0Y2FudmFzLmhlaWdodCA9IDYwNjtcblx0ZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuXHQvKiBUaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyB0aGUga2lja29mZiBwb2ludCBmb3IgdGhlIGdhbWUgbG9vcCBpdHNlbGZcblx0ICogYW5kIGhhbmRsZXMgcHJvcGVybHkgY2FsbGluZyB0aGUgdXBkYXRlIGFuZCByZW5kZXIgbWV0aG9kcy5cblx0ICovXG5cdGZ1bmN0aW9uIG1haW4oKSB7XG5cdFx0LyogR2V0IG91ciB0aW1lIGRlbHRhIGluZm9ybWF0aW9uIHdoaWNoIGlzIHJlcXVpcmVkIGlmIHlvdXIgZ2FtZVxuXHRcdCAqIHJlcXVpcmVzIHNtb290aCBhbmltYXRpb24uIEJlY2F1c2UgZXZlcnlvbmUncyBjb21wdXRlciBwcm9jZXNzZXNcblx0XHQgKiBpbnN0cnVjdGlvbnMgYXQgZGlmZmVyZW50IHNwZWVkcyB3ZSBuZWVkIGEgY29uc3RhbnQgdmFsdWUgdGhhdFxuXHRcdCAqIHdvdWxkIGJlIHRoZSBzYW1lIGZvciBldmVyeW9uZSAocmVnYXJkbGVzcyBvZiBob3cgZmFzdCB0aGVpclxuXHRcdCAqIGNvbXB1dGVyIGlzKSAtIGh1cnJheSB0aW1lIVxuXHRcdCAqL1xuXG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCksXG5cdFx0XHRkdCA9IChub3cgLSBsYXN0VGltZSkgLyAxMDAwLjAsXG5cdFx0XHRzcHJpdGUgPSBcIlwiO1xuXG5cdFx0LyogQ2FsbCBvdXIgdXBkYXRlL3JlbmRlciBmdW5jdGlvbnMsIHBhc3MgYWxvbmcgdGhlIHRpbWUgZGVsdGEgdG9cblx0XHQgKiBvdXIgdXBkYXRlIGZ1bmN0aW9uIHNpbmNlIGl0IG1heSBiZSB1c2VkIGZvciBzbW9vdGggYW5pbWF0aW9uLlxuXHRcdCAqL1xuXHRcdGlmIChwbGF5ZXIuaXNHYW1lT3ZlciA9PSBmYWxzZSkge1xuXHRcdFx0dXBkYXRlKGR0KTtcblx0XHR9XG5cdFx0cmVuZGVyKCk7XG5cblx0XHQvKiBTZXQgb3VyIGxhc3RUaW1lIHZhcmlhYmxlIHdoaWNoIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aW1lIGRlbHRhXG5cdFx0ICogZm9yIHRoZSBuZXh0IHRpbWUgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQuXG5cdFx0ICovXG5cdFx0bGFzdFRpbWUgPSBub3c7XG5cblx0XHQvKiBVc2UgdGhlIGJyb3dzZXIncyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24gdG8gY2FsbCB0aGlzXG5cdFx0ICogZnVuY3Rpb24gYWdhaW4gYXMgc29vbiBhcyB0aGUgYnJvd3NlciBpcyBhYmxlIHRvIGRyYXcgYW5vdGhlciBmcmFtZS5cblx0XHQgKi9cblx0XHRpZiAocGxheWVyLmlzR2FtZU92ZXIgPT0gZmFsc2UpIHtcblx0XHRcdHdpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobWFpbik7XG5cdFx0fVxuXHR9XG5cblx0LyogVGhpcyBmdW5jdGlvbiBkb2VzIHNvbWUgaW5pdGlhbCBzZXR1cCB0aGF0IHNob3VsZCBvbmx5IG9jY3VyIG9uY2UsXG5cdCAqIHBhcnRpY3VsYXJseSBzZXR0aW5nIHRoZSBsYXN0VGltZSB2YXJpYWJsZSB0aGF0IGlzIHJlcXVpcmVkIGZvciB0aGVcblx0ICogZ2FtZSBsb29wLlxuXHQgKi9cblx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRsYXN0VGltZSA9IERhdGUubm93KCk7XG5cdFx0bWFpbigpO1xuXHRcdC8vcmVzZXQoKTtcblx0fVxuXG5cdC8qIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IG1haW4gKG91ciBnYW1lIGxvb3ApIGFuZCBpdHNlbGYgY2FsbHMgYWxsXG5cdCAqIG9mIHRoZSBmdW5jdGlvbnMgd2hpY2ggbWF5IG5lZWQgdG8gdXBkYXRlIGVudGl0eSdzIGRhdGEuIEJhc2VkIG9uIGhvd1xuXHQgKiB5b3UgaW1wbGVtZW50IHlvdXIgY29sbGlzaW9uIGRldGVjdGlvbiAod2hlbiB0d28gZW50aXRpZXMgb2NjdXB5IHRoZVxuXHQgKiBzYW1lIHNwYWNlLCBmb3IgaW5zdGFuY2Ugd2hlbiB5b3VyIGNoYXJhY3RlciBzaG91bGQgZGllKSwgeW91IG1heSBmaW5kXG5cdCAqIHRoZSBuZWVkIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGZ1bmN0aW9uIGNhbGwgaGVyZS4gRm9yIG5vdywgd2UndmUgbGVmdFxuXHQgKiBpdCBjb21tZW50ZWQgb3V0IC0geW91IG1heSBvciBtYXkgbm90IHdhbnQgdG8gaW1wbGVtZW50IHRoaXNcblx0ICogZnVuY3Rpb25hbGl0eSB0aGlzIHdheSAoeW91IGNvdWxkIGp1c3QgaW1wbGVtZW50IGNvbGxpc2lvbiBkZXRlY3Rpb25cblx0ICogb24gdGhlIGVudGl0aWVzIHRoZW1zZWx2ZXMgd2l0aGluIHlvdXIgYXBwLmpzIGZpbGUpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdXBkYXRlKGR0KSB7XG5cdFx0dXBkYXRlRW50aXRpZXMoZHQpO1xuXHRcdGNoZWNrQ29sbGlzaW9ucygpO1xuXHR9XG5cblx0LyogVGhpcyBpcyBjYWxsZWQgYnkgdGhlIHVwZGF0ZSBmdW5jdGlvbiBhbmQgbG9vcHMgdGhyb3VnaCBhbGwgb2YgdGhlXG5cdCAqIG9iamVjdHMgd2l0aGluIHlvdXIgYWxsRW5lbWllcyBhcnJheSBhcyBkZWZpbmVkIGluIGFwcC5qcyBhbmQgY2FsbHNcblx0ICogdGhlaXIgdXBkYXRlKCkgbWV0aG9kcy4gSXQgd2lsbCB0aGVuIGNhbGwgdGhlIHVwZGF0ZSBmdW5jdGlvbiBmb3IgeW91clxuXHQgKiBwbGF5ZXIgb2JqZWN0LiBUaGVzZSB1cGRhdGUgbWV0aG9kcyBzaG91bGQgZm9jdXMgcHVyZWx5IG9uIHVwZGF0aW5nXG5cdCAqIHRoZSBkYXRhL3Byb3BlcnRpZXMgcmVsYXRlZCB0byB0aGUgb2JqZWN0LiBEbyB5b3VyIGRyYXdpbmcgaW4geW91clxuXHQgKiByZW5kZXIgbWV0aG9kcy5cblx0ICovXG5cdGZ1bmN0aW9uIHVwZGF0ZUVudGl0aWVzKGR0KSB7XG5cdFx0YWxsRW5lbWllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbmVteSkge1xuXHRcdFx0ZW5lbXkudXBkYXRlKGR0KTtcblx0XHR9KTtcblx0XHRwbGF5ZXIudXBkYXRlKGR0KTtcblx0fVxuXG5cblx0LyogVGhpcyBjaGVja3MgZm9yIGNvbGxpc2lvbnMgYmV0d2VlbiBhbiBlbmVteSBhbmQgcGxheWVyXG5cdCAqIFNpbmNlIGVudGl0aWVzIGFyZSBvbiBheGVzIGFuZCBoYXZlIHdpZHRoIGFuZCBoZWlnaHRcblx0ICogaXQncyBwb3NzaWJsZSB0byBjaGVjayBmb3IgZ2FwcyBiZXR3ZWVuIHRoZW0uIFxuXHQgKiBJZiB0aGF0J3MgdGhlIGNhc2UgdGhlbiBhIGNvbGxpc2lvbiBoYXBwZW5kLFxuXHQgKiBhbmQgdGhlIHBsYXllciBnb2VzIGJhY2sgdG8gaXRzIGluaXRpYWwgcG9zaXRpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja0NvbGxpc2lvbnMoKSB7XG5cdFx0YWxsRW5lbWllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbmVteSkge1xuXHRcdFx0ZW5lbXkuaGFuZGxlQ29sbGlzaW9ucygpO1xuXHRcdH0pXG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxseSBkcmF3cyB0aGUgXCJnYW1lIGxldmVsXCIsIGl0IHdpbGwgdGhlbiBjYWxsXG5cdCAqIHRoZSByZW5kZXJFbnRpdGllcyBmdW5jdGlvbi4gUmVtZW1iZXIsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGV2ZXJ5XG5cdCAqIGdhbWUgdGljayAob3IgbG9vcCBvZiB0aGUgZ2FtZSBlbmdpbmUpIGJlY2F1c2UgdGhhdCdzIGhvdyBnYW1lcyB3b3JrIC1cblx0ICogdGhleSBhcmUgZmxpcGJvb2tzIGNyZWF0aW5nIHRoZSBpbGx1c2lvbiBvZiBhbmltYXRpb24gYnV0IGluIHJlYWxpdHlcblx0ICogdGhleSBhcmUganVzdCBkcmF3aW5nIHRoZSBlbnRpcmUgc2NyZWVuIG92ZXIgYW5kIG92ZXIuXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHQvKiBUaGlzIGFycmF5IGhvbGRzIHRoZSByZWxhdGl2ZSBVUkwgdG8gdGhlIGltYWdlIHVzZWRcblx0XHQgKiBmb3IgdGhhdCBwYXJ0aWN1bGFyIHJvdyBvZiB0aGUgZ2FtZSBsZXZlbC5cblx0XHQgKi9cblx0XHR2YXIgcm93SW1hZ2VzID0gW1xuICAgICAgICAgICAgICAgICdpbWFnZXMvd2F0ZXItYmxvY2sucG5nJywgLy8gVG9wIHJvdyBpcyB3YXRlclxuICAgICAgICAgICAgICAgICdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgLy8gUm93IDEgb2YgMyBvZiBzdG9uZVxuICAgICAgICAgICAgICAgICdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgLy8gUm93IDIgb2YgMyBvZiBzdG9uZVxuICAgICAgICAgICAgICAgICdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJywgLy8gUm93IDMgb2YgMyBvZiBzdG9uZVxuICAgICAgICAgICAgICAgICdpbWFnZXMvZ3Jhc3MtYmxvY2sucG5nJywgLy8gUm93IDEgb2YgMiBvZiBncmFzc1xuICAgICAgICAgICAgICAgICdpbWFnZXMvZ3Jhc3MtYmxvY2sucG5nJyAvLyBSb3cgMiBvZiAyIG9mIGdyYXNzXG4gICAgICAgICAgICBdLFxuXHRcdFx0bnVtUm93cyA9IDYsXG5cdFx0XHRudW1Db2xzID0gNSxcblx0XHRcdHJvdywgY29sO1xuXG5cdFx0Ly8gQmVmb3JlIGRyYXdpbmcsIGNsZWFyIGV4aXN0aW5nIGNhbnZhc1xuXHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuXG5cdFx0LyogTG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB3ZSd2ZSBkZWZpbmVkIGFib3ZlXG5cdFx0ICogYW5kLCB1c2luZyB0aGUgcm93SW1hZ2VzIGFycmF5LCBkcmF3IHRoZSBjb3JyZWN0IGltYWdlIGZvciB0aGF0XG5cdFx0ICogcG9ydGlvbiBvZiB0aGUgXCJncmlkXCJcblx0XHQgKi9cblx0XHRmb3IgKHJvdyA9IDA7IHJvdyA8IG51bVJvd3M7IHJvdysrKSB7XG5cdFx0XHRmb3IgKGNvbCA9IDA7IGNvbCA8IG51bUNvbHM7IGNvbCsrKSB7XG5cdFx0XHRcdC8qIFRoZSBkcmF3SW1hZ2UgZnVuY3Rpb24gb2YgdGhlIGNhbnZhcycgY29udGV4dCBlbGVtZW50XG5cdFx0XHRcdCAqIHJlcXVpcmVzIDMgcGFyYW1ldGVyczogdGhlIGltYWdlIHRvIGRyYXcsIHRoZSB4IGNvb3JkaW5hdGVcblx0XHRcdFx0ICogdG8gc3RhcnQgZHJhd2luZyBhbmQgdGhlIHkgY29vcmRpbmF0ZSB0byBzdGFydCBkcmF3aW5nLlxuXHRcdFx0XHQgKiBXZSdyZSB1c2luZyBvdXIgUmVzb3VyY2VzIGhlbHBlcnMgdG8gcmVmZXIgdG8gb3VyIGltYWdlc1xuXHRcdFx0XHQgKiBzbyB0aGF0IHdlIGdldCB0aGUgYmVuZWZpdHMgb2YgY2FjaGluZyB0aGVzZSBpbWFnZXMsIHNpbmNlXG5cdFx0XHRcdCAqIHdlJ3JlIHVzaW5nIHRoZW0gb3ZlciBhbmQgb3Zlci5cblx0XHRcdFx0ICovXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoUmVzb3VyY2VzLmdldChyb3dJbWFnZXNbcm93XSksIGNvbCAqIDEwMSwgcm93ICogODMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJlbmRlckVudGl0aWVzKCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGFuZCBpcyBjYWxsZWQgb24gZWFjaCBnYW1lXG5cdCAqIHRpY2suIEl0cyBwdXJwb3NlIGlzIHRvIHRoZW4gY2FsbCB0aGUgcmVuZGVyIGZ1bmN0aW9ucyB5b3UgaGF2ZSBkZWZpbmVkXG5cdCAqIG9uIHlvdXIgZW5lbXkgYW5kIHBsYXllciBlbnRpdGllcyB3aXRoaW4gYXBwLmpzXG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXJFbnRpdGllcygpIHtcblx0XHQvKiBMb29wIHRocm91Z2ggYWxsIG9mIHRoZSBvYmplY3RzIHdpdGhpbiB0aGUgYWxsRW5lbWllcyBhcnJheSBhbmQgY2FsbFxuXHRcdCAqIHRoZSByZW5kZXIgZnVuY3Rpb24geW91IGhhdmUgZGVmaW5lZC5cblx0XHQgKi9cblx0XHRhbGxFbmVtaWVzLmZvckVhY2goZnVuY3Rpb24gKGVuZW15KSB7XG5cdFx0XHRlbmVteS5yZW5kZXIoKTtcblx0XHR9KTtcblx0XHRwbGF5ZXIucmVuZGVyKCk7XG5cdH1cblxuXHQvKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90aGluZyBidXQgaXQgY291bGQgaGF2ZSBiZWVuIGEgZ29vZCBwbGFjZSB0b1xuXHQgKiBoYW5kbGUgZ2FtZSByZXNldCBzdGF0ZXMgLSBtYXliZSBhIG5ldyBnYW1lIG1lbnUgb3IgYSBnYW1lIG92ZXIgc2NyZWVuXG5cdCAqIHRob3NlIHNvcnRzIG9mIHRoaW5ncy4gSXQncyBvbmx5IGNhbGxlZCBvbmNlIGJ5IHRoZSBpbml0KCkgbWV0aG9kLlxuXHQgKi9cblx0Ly8gZnVuY3Rpb24gcmVzZXQoKXt9XG5cblx0LyogR28gYWhlYWQgYW5kIGxvYWQgYWxsIG9mIHRoZSBpbWFnZXMgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBuZWVkIHRvXG5cdCAqIGRyYXcgb3VyIGdhbWUgbGV2ZWwuIFRoZW4gc2V0IGluaXQgYXMgdGhlIGNhbGxiYWNrIG1ldGhvZCwgc28gdGhhdCB3aGVuXG5cdCAqIGFsbCBvZiB0aGVzZSBpbWFnZXMgYXJlIHByb3Blcmx5IGxvYWRlZCBvdXIgZ2FtZSB3aWxsIHN0YXJ0LlxuXHQgKi9cblxuXHRSZXNvdXJjZXMubG9hZChbXG4gICAgICAgICdpbWFnZXMvc3RvbmUtYmxvY2sucG5nJyxcbiAgICAgICAgJ2ltYWdlcy93YXRlci1ibG9jay5wbmcnLFxuICAgICAgICAnaW1hZ2VzL2dyYXNzLWJsb2NrLnBuZycsXG4gICAgICAgICdpbWFnZXMvZW5lbXktYnVnLnBuZycsXG4gICAgICAgICdpbWFnZXMvY2hhci1ib3kucG5nJyxcblx0XHQnaW1hZ2VzL2NoYXItY2F0LWdpcmwucG5nJyxcblx0XHQnaW1hZ2VzL2NoYXItaG9ybi1naXJsLnBuZycsXG5cdFx0J2ltYWdlcy9jaGFyLXBpbmstZ2lybC5wbmcnLFxuXHRcdCdpbWFnZXMvY2hhci1wcmluY2Vzcy1naXJsLnBuZydcblx0XSk7XG5cdFJlc291cmNlcy5vblJlYWR5KGluaXQpO1xuXG5cdC8qIEFzc2lnbiB0aGUgY2FudmFzJyBjb250ZXh0IG9iamVjdCB0byB0aGUgZ2xvYmFsIHZhcmlhYmxlICh0aGUgd2luZG93XG5cdCAqIG9iamVjdCB3aGVuIHJ1biBpbiBhIGJyb3dzZXIpIHNvIHRoYXQgZGV2ZWxvcGVycyBjYW4gdXNlIGl0IG1vcmUgZWFzaWx5XG5cdCAqIGZyb20gd2l0aGluIHRoZWlyIGFwcC5qcyBmaWxlcy5cblx0ICovXG5cdGdsb2JhbC5jdHggPSBjdHg7XG59KSh0aGlzKTtcbiJdLCJmaWxlIjoianMvYWxsLm1pbi5qcyJ9
