{"version":3,"sources":["js/resources.js","js/app.js","js/engine.js"],"names":["resourceCache","readyCallbacks","_load","url","img","Image","onload","isReady","forEach","func","src","ready","k","hasOwnProperty","window","Resources","load","urlOrArr","Array","get","onReady","push","modalC","document","getElementById","modalWin","modalGameOver","modalBtnWin","modalBtnC","characters","getElementsByClassName","isCharSelected","heartN1","heartN2","heartN3","item","localStorage","getItem","classList","add","Character","[object Object]","x","y","width","height","speed","sprite","this","ctx","drawImage","Enemy","super","prototype","update","dt","randomN","Math","floor","random","render","handleCollisions","player","lives","loseLife","life1","life2","isGameOver","setTimeout","endGame","Player","isKeyUp","direction","life3","handleInput","key","winGame","life","style","display","addEventListener","e","keyCode","reloadAfterWin","listener","location","reload","myChar","enemy0","enemy1","enemy2","allEnemies","37","38","39","40","character","remove","savedChar","getIndex","setItem","target","id","console","log","el","children","parentElement","i","len","length","Engine","global","lastTime","doc","win","canvas","createElement","getContext","main","now","Date","enemy","updateEntities","row","col","rowImages","clearRect","requestAnimationFrame","body","appendChild"],"mappings":"CAMA,WACA,IAAAA,KAEAC,KA2BA,SAAAC,EAAAC,GACA,GAAAH,EAAAG,GAKA,OAAAH,EAAAG,GAKA,IAAAC,EAAA,IAAAC,MACAD,EAAAE,OAAA,WAKAN,EAAAG,GAAAC,EAKAG,KACAN,EAAAO,QAAA,SAAAC,GAAAA,OAQAT,EAAAG,IAAA,EACAC,EAAAM,IAAAP,EAeA,SAAAI,IACA,IAAAI,GAAA,EACA,IAAA,IAAAC,KAAAZ,EACAA,EAAAa,eAAAD,KACAZ,EAAAY,KACAD,GAAA,GAGA,OAAAA,EAaAG,OAAAC,WACAC,KA1FA,SAAAC,GACAA,aAAAC,MAKAD,EAAAT,QAAA,SAAAL,GACAD,EAAAC,KAOAD,EAAAe,IA6EAE,IA9BA,SAAAhB,GACA,OAAAH,EAAAG,IA8BAiB,QAVA,SAAAX,GACAR,EAAAoB,KAAAZ,IAUAF,QAAAA,GAtGA,GCNA,MAAAe,OAAAC,SAAAC,eAAA,WACAC,SAAAF,SAAAC,eAAA,aACAE,cAAAH,SAAAC,eAAA,mBACAG,YAAAJ,SAAAC,eAAA,iBACAI,UAAAL,SAAAC,eAAA,eACA,IAAAK,WAAAP,OAAAQ,uBAAA,oBACAC,gBAAA,EACAC,QAAAT,SAAAC,eAAA,UACAS,QAAAV,SAAAC,eAAA,UACAU,QAAAX,SAAAC,eAAA,UAGAK,WAAAM,KAAAC,aAAAC,QAAA,YAAAC,UAAAC,IAAA,YACAR,gBAAA,QAOAS,UACAC,YAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEAC,KAAAN,EAAAA,EAGAM,KAAAL,EAAAA,EAGAK,KAAAJ,MAAAA,EACAI,KAAAH,OAAAA,EAGAG,KAAAF,MAAAA,EAEAE,KAAAD,OAAAA,EAIAN,SAEAQ,IAAAC,UAAAnC,UAAAI,IAAA6B,KAAAD,QAAAC,KAAAN,EAAAM,KAAAL,UASAQ,cAAAX,UACAC,YAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAK,MAAAV,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,IAMAI,MAAAE,UAAAC,OAAA,SAAAC,GAGA,IAAAC,EAAAC,KAAAC,MAAA,EAAAD,KAAAE,SAAA,GAIAX,KAAAN,EAAA,MAIAM,KAAAN,GAAA,IAGA,IAAAc,GACAR,KAAAL,EAAA,GACAK,KAAAF,MAAA,KACA,IAAAU,GACAR,KAAAL,EAAA,IACAK,KAAAF,MAAA,KACA,IAAAU,IACAR,KAAAL,EAAA,IACAK,KAAAF,MAAA,MAIAE,KAAAN,GAAAM,KAAAF,MAAAS,GAKAJ,MAAAE,UAAAO,OAAA,WAEAX,IAAAC,UAAAnC,UAAAI,IAAA6B,KAAAD,QAAAC,KAAAN,EAAAM,KAAAL,IAOAQ,MAAAE,UAAAQ,iBAAA,WAEAb,KAAAN,EAAAoB,OAAApB,EAAAoB,OAAAlB,OACAI,KAAAN,EAAAM,KAAAJ,MAAAkB,OAAApB,GACAM,KAAAL,EAAAmB,OAAAnB,EAAAmB,OAAAjB,QACAG,KAAAL,EAAAK,KAAAH,OAAAiB,OAAAnB,IAGA,IAAAmB,OAAAC,MACAD,OAAAE,SAAAF,OAAAG,OACA,IAAAH,OAAAC,MACAD,OAAAE,SAAAF,OAAAI,QAGAJ,OAAAK,YAAA,EACAC,WAAA,WACAN,OAAAO,WACA,cAWAC,eAAA9B,UAEAC,YAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAwB,EAAAC,EAAAT,EAAAE,EAAAC,EAAAO,EAAAN,GACAf,MAAAV,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAGAC,KAAAuB,SAAA,EAIAvB,KAAAwB,UAAA,GAGAxB,KAAAe,MAAA,EAGAf,KAAAiB,MAAAjC,QACAgB,KAAAkB,MAAAjC,QACAe,KAAAyB,MAAAvC,QAGAc,KAAAmB,YAAA,GAKAG,OAAAjB,UAAAC,OAAA,SAAAC,GAEA,UAAAP,KAAAwB,WACAxB,KAAAN,GAAAM,KAAAF,MAAAS,EACAP,KAAAF,MAAA,GACA,SAAAE,KAAAwB,WACAxB,KAAAN,GAAAM,KAAAF,MAAAS,EACAP,KAAAF,MAAA,GACA,OAAAE,KAAAwB,WACAxB,KAAAL,GAAAK,KAAAF,MAAAS,EACAP,KAAAF,MAAA,GACA,SAAAE,KAAAwB,YACAxB,KAAAL,GAAAK,KAAAF,MAAAS,EACAP,KAAAF,MAAA,IASAwB,OAAAjB,UAAAqB,YAAA,SAAAC,GAGA,UAAAA,GAAA3B,KAAAuB,SAAAvB,KAAAN,EAAA,KACAM,KAAAwB,UAAA,QACAxB,KAAAF,MAAA,KACA,SAAA6B,GAAA3B,KAAAuB,SAAAvB,KAAAN,EAAA,IACAM,KAAAwB,UAAA,OACAxB,KAAAF,MAAA,KACA,OAAA6B,GAAA3B,KAAAuB,SAAAvB,KAAAL,EAAA,IACAK,KAAAwB,UAAA,KACAxB,KAAAF,MAAA,MACA,OAAA6B,GAAA3B,KAAAuB,SAAAvB,KAAAL,EAAA,GAEAmB,OAAAc,UACA,SAAAD,GAAA3B,KAAAuB,SAAAvB,KAAAL,EAAA,MACAK,KAAAwB,UAAA,OACAxB,KAAAF,MAAA,OAaAwB,OAAAjB,UAAAW,SAAA,SAAAa,GACAf,OAAAC,QACAc,EAAAC,MAAAC,QAAA,OACAjB,OAAApB,EAAA,IACAoB,OAAAnB,EAAA,KAQA2B,OAAAjB,UAAAuB,QAAA,WACAnD,SAAAqD,MAAAC,QAAA,QAEAxD,SAAAyD,iBAAA,UAAA,SAAAC,GACA,KAAAA,EAAAC,SACAC,mBAIAxD,YAAAqD,iBAAA,QAAA,WACAG,oBASAb,OAAAjB,UAAAgB,QAAA,WACAP,OAAAK,YAAA,EACAzC,cAAAoD,MAAAC,QAAA,SACA,UAAA,gBAAAvE,QAAA4E,GACA7D,SAAAyD,iBAAAI,EAAA,SAAAH,IAEA,YAAAG,GAAA,KAAAH,EAAAC,SAAA,KAAAD,EAAAC,SACA,iBAAAE,IACAtE,OAAAuE,SAAAC,QAAA,KAEA,KAKA,IAAAxB,OAAA,IAAAQ,OAAA,IAAA,IAAA,GAAA,GAAA,GACAR,OAAAf,OAAAX,aAAAmD,OAAAnD,aAAAmD,OAAA,sBAGA,IAAAC,OAAA,IAAArC,OAAA,IAAA,GAAA,GAAA,GAAA,IAAA,wBACAsC,OAAA,IAAAtC,OAAA,IAAA,GAAA,GAAA,GAAA,IAAA,wBACAuC,OAAA,IAAAvC,OAAA,IAAA,GAAA,GAAA,GAAA,IAAA,wBAKAwC,cASA,SAAAR,iBAEArE,OAAAuE,SAAAC,QAAA,GARAK,WAAAtE,KAAAmE,OAAAC,OAAAC,QAaAnE,SAAAyD,iBAAA,QAAA,SAAAC,GAQAnB,OAAAS,SAAA,EAEAT,OAAAY,aARAkB,GAAA,OACAC,GAAA,KACAC,GAAA,QACAC,GAAA,QAKAd,EAAAC,YAYA,IAAA,IAAAc,KAAAnE,WACAmE,EAAAhB,iBAAA,QAAA,SAAAC,GAEA,IAAA,IAAAe,KAAAnE,WACAmE,EAAA1D,UAAA2D,OAAA,YACAlE,gBAAA,EAGAiB,KAAAV,UAAAC,IAAA,YAEA2D,UAAAC,SAAAH,GAEAjE,gBAAA,EAEAK,aAAAgE,QAAA,UAAAF,WAEA,QAAAjB,EAAAoB,OAAAC,GACAxC,OAAAf,OAAA,sBACA,aAAAkC,EAAAoB,OAAAC,GACAxC,OAAAf,OAAA,2BACA,cAAAkC,EAAAoB,OAAAC,GACAxC,OAAAf,OAAA,4BACA,cAAAkC,EAAAoB,OAAAC,GACAxC,OAAAf,OAAA,4BAEAe,OAAAf,OAAA,gCAGAX,aAAAgE,QAAA,SAAAtC,OAAAf,QACAwD,QAAAC,IAAApE,gBAiBA,SAAA+D,SAAAM,GACA,IAAAC,EAAAD,EAAAE,cAAAD,SAEA,IAAA,IAAAE,EAAA,EAAAC,EAAAH,EAAAI,OAAAF,EAAAC,EAAAD,IAGA,GAAAF,EAAAE,KAAAH,EACA,OAAAG,EAdAhF,UAAAoD,iBAAA,QAAA,WACA,GAAAjD,iBAGAT,OAAAwD,MAAAC,QAAA,UCvUA,IAAAgC,OAAA,SAAAC,GAKA,IAIAC,EAJAC,EAAAF,EAAAzF,SACA4F,EAAAH,EAAAlG,OACAsG,EAAAF,EAAAG,cAAA,UACApE,EAAAmE,EAAAE,WAAA,MAUA,SAAAC,IAQA,IAAAC,EAAAC,KAAAD,MACAjE,GAAAiE,EAAAP,GAAA,IAMA,GAAAnD,OAAAK,YAoCA,SAAAZ,IAYA,SAAAA,GACAoC,WAAAnF,QAAA,SAAAkH,GACAA,EAAApE,OAAAC,KAEAO,OAAAR,OAAAC,IAfAoE,CAAApE,GA0BAoC,WAAAnF,QAAA,SAAAkH,GACAA,EAAA7D,qBA/DAP,CAAAC,GA0EA,WAIA,IAUAqE,EAAAC,EAVAC,GACA,yBACA,yBACA,yBACA,yBACA,yBACA,0BAaA,IANA7E,EAAA8E,UAAA,EAAA,EAAAX,EAAAxE,MAAAwE,EAAAvE,QAMA+E,EAAA,EAAAA,EAXA,EAWAA,IACA,IAAAC,EAAA,EAAAA,EAXA,EAWAA,IAQA5E,EAAAC,UAAAnC,UAAAI,IAAA2G,EAAAF,IAAA,IAAAC,EAAA,GAAAD,GAeAjC,WAAAnF,QAAA,SAAAkH,GACAA,EAAA9D,WAEAE,OAAAF,SA1HAA,GAKAqD,EAAAO,EAKA,GAAA1D,OAAAK,YACAgD,EAAAa,sBAAAT,GApCAH,EAAAxE,MAAA,IACAwE,EAAAvE,OAAA,IACAqE,EAAAe,KAAAC,YAAAd,GA+JArG,UAAAC,MACA,yBACA,yBACA,yBACA,uBACA,sBACA,2BACA,4BACA,4BACA,kCAEAD,UAAAK,QAhIA,WACA6F,EAAAQ,KAAAD,MACAD,MAoIAP,EAAA/D,IAAAA,EA7LA,CA8LAD","file":"all.js","sourcesContent":["    /* Resources.js\n * This is simply an image loading utility. It eases the process of loading\n * image files so that they can be used within your game. It also includes\n * a simple \"caching\" layer so it will reuse cached images if you attempt\n * to load the same image multiple times.\n */\n(function() {\n    var resourceCache = {};\n    var loading = [];\n    var readyCallbacks = [];\n\n    /* This is the publicly accessible image loading function. It accepts\n     * an array of strings pointing to image files or a string for a single\n     * image. It will then call our private image loading function accordingly.\n     */\n    function load(urlOrArr) {\n        if(urlOrArr instanceof Array) {\n            /* If the developer passed in an array of images\n             * loop through each value and call our image\n             * loader on that image file\n             */\n            urlOrArr.forEach(function(url) {\n                _load(url);\n            });\n        } else {\n            /* The developer did not pass an array to this function,\n             * assume the value is a string and call our image loader\n             * directly.\n             */\n            _load(urlOrArr);\n        }\n    }\n\n    /* This is our private image loader function, it is\n     * called by the public image loader function.\n     */\n    function _load(url) {\n        if(resourceCache[url]) {\n            /* If this URL has been previously loaded it will exist within\n             * our resourceCache array. Just return that image rather\n             * re-loading the image.\n             */\n            return resourceCache[url];\n        } else {\n            /* This URL has not been previously loaded and is not present\n             * within our cache; we'll need to load this image.\n             */\n            var img = new Image();\n            img.onload = function() {\n                /* Once our image has properly loaded, add it to our cache\n                 * so that we can simply return this image if the developer\n                 * attempts to load this file in the future.\n                 */\n                resourceCache[url] = img;\n\n                /* Once the image is actually loaded and properly cached,\n                 * call all of the onReady() callbacks we have defined.\n                 */\n                if(isReady()) {\n                    readyCallbacks.forEach(function(func) { func(); });\n                }\n            };\n\n            /* Set the initial cache value to false, this will change when\n             * the image's onload event handler is called. Finally, point\n             * the image's src attribute to the passed in URL.\n             */\n            resourceCache[url] = false;\n            img.src = url;\n        }\n    }\n\n    /* This is used by developers to grab references to images they know\n     * have been previously loaded. If an image is cached, this functions\n     * the same as calling load() on that URL.\n     */\n    function get(url) {\n        return resourceCache[url];\n    }\n\n    /* This function determines if all of the images that have been requested\n     * for loading have in fact been properly loaded.\n     */\n    function isReady() {\n        var ready = true;\n        for(var k in resourceCache) {\n            if(resourceCache.hasOwnProperty(k) &&\n               !resourceCache[k]) {\n                ready = false;\n            }\n        }\n        return ready;\n    }\n\n    /* This function will add a function to the callback stack that is called\n     * when all requested images are properly loaded.\n     */\n    function onReady(func) {\n        readyCallbacks.push(func);\n    }\n\n    /* This object defines the publicly accessible functions available to\n     * developers by creating a global Resources object.\n     */\n    window.Resources = {\n        load: load,\n        get: get,\n        onReady: onReady,\n        isReady: isReady\n    };\n})();\n","const modalC = document.getElementById('c-modal'),\n\tmodalWin = document.getElementById('win-modal'),\n\tmodalGameOver = document.getElementById('game-over-modal'),\n\tmodalBtnWin = document.getElementById('modal-btn-win'),\n\tmodalBtnC = document.getElementById('modal-btn-c');\nvar characters = modalC.getElementsByClassName('modal__character'),\n\tisCharSelected = true,\n\theartN1 = document.getElementById('heart1'),\n\theartN2 = document.getElementById('heart2'),\n\theartN3 = document.getElementById('heart3');\n\n(function () {\n\tcharacters.item(localStorage.getItem('myValue')).classList.add('selected');\n\tisCharSelected = true;\n})();\n\n/*\n\t-------------------- PARRENT CLASS ----------------------\n*/\n\nclass Character {\n\tconstructor(x, y, width, height, speed, sprite) {\n\t\t// Set enemy location\n\t\tthis.x = x;\n\n\t\t// Set enemy initial location\n\t\tthis.y = y;\n\n\t\t// set width and height: to use in Enemy.handleCollision() method \n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\t// Set enemy initial speed\n\t\tthis.speed = speed;\n\n\t\tthis.sprite = sprite;\n\n\t}\n\n\trender() {\n\t\t//at this point the image hasn't been loaded yet\n\t\tctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n\t}\n}\n\n/*\n\t------------------------------------------- SUBCLASS: ENEMY\n*/\n\n// Enemies our player must avoid\nclass Enemy extends Character {\n\tconstructor(x, y, width, height, speed, sprite) {\n\t\tsuper(x, y, width, height, speed, sprite);\n\t}\n}\n\n// Update the enemy's position, required method for game\n// Parameter: dt, a time delta between ticks\nEnemy.prototype.update = function (dt) {\n\n\t// Calculate random number between 1 and 3\n\tlet randomN = Math.floor((Math.random() * 3) + 1);\n\n\t// When enemy is off-screen\n\t// randomize new position at which it's created\n\tif (this.x > 520) {\n\n\t\t// Reset x coordinate to off-screen\n\t\t// left side\n\t\tthis.x = -120;\n\n\t\t// Generate enemy on one of the stone rows\n\t\tif (randomN === 1) {\n\t\t\tthis.y = 60;\n\t\t\tthis.speed = 500;\n\t\t} else if (randomN === 2) {\n\t\t\tthis.y = 140;\n\t\t\tthis.speed = 600;\n\t\t} else if (randomN === 3) {\n\t\t\tthis.y = 230;\n\t\t\tthis.speed = 700;\n\t\t}\n\t}\n\n\tthis.x += (this.speed * dt);\n\n};\n\n// Draw the enemy on the screen, required method for game\nEnemy.prototype.render = function () {\n\n\tctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n};\n\n/* \n * Parameter: check if enemy and player collide.\n * If so, reset player to its initial location\n */\nEnemy.prototype.handleCollisions = function () {\n\n\tif (this.x < player.x + player.width &&\n\t\tthis.x + this.width > player.x &&\n\t\tthis.y < player.y + player.height &&\n\t\tthis.y + this.height > player.y) {\n\n\t\t// Handle lives \n\t\tif (player.lives === 3) {\n\t\t\tplayer.loseLife(player.life1);\n\t\t} else if (player.lives === 2) {\n\t\t\tplayer.loseLife(player.life2);\n\t\t} else {\n\t\t\t// Handle Game Over\n\t\t\tplayer.isGameOver = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\tplayer.endGame();\n\t\t\t}, 1000);\n\t\t}\n\t}\n}\n\n\n/*\n\t---------------------------------------------- SUBCLASS: PLAYER\n */\n\n// Player class\nclass Player extends Character {\n\n\tconstructor(x, y, width, height, speed, sprite, isKeyUp, direction, lives, life1, life2, life3, isGameOver) {\n\t\tsuper(x, y, width, height, speed, sprite);\n\n\t\t// Boolean: to use in Player.handleInput() method\n\t\tthis.isKeyUp = true;\n\n\t\t// Set player directon. Empty.\n\t\t// It changes in player.handleInput() to give direction to movement\n\t\tthis.direction = '';\n\n\t\t// Set player initial lives number\n\t\tthis.lives = 3;\n\n\t\t// Assign hearts elements to three variables. To use in player.loseLife() method\n\t\tthis.life1 = heartN1;\n\t\tthis.life2 = heartN2;\n\t\tthis.life3 = heartN3;\n\n\t\t// Boolean. Use it to check if game is over \n\t\tthis.isGameOver = false;\n\t}\n}\n\n// Updates player position\nPlayer.prototype.update = function (dt) {\n\n\tif (this.direction === 'right') {\n\t\tthis.x += (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'left') {\n\t\tthis.x -= (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'up') {\n\t\tthis.y -= (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'down') {\n\t\tthis.y += (this.speed * dt);\n\t\tthis.speed = 0;\n\t}\n\n}\n\n/* Player handleInput() method:\n * based on key input sets direction, speed\n * and checks win conditions\n */\nPlayer.prototype.handleInput = function (key) {\n\n\t// handle direction and speed of movement\n\tif (key === 'right' && this.isKeyUp && this.x < 380) {\n\t\tthis.direction = 'right';\n\t\tthis.speed = 4000;\n\t} else if (key === 'left' && this.isKeyUp && this.x > 33) {\n\t\tthis.direction = 'left';\n\t\tthis.speed = 4000;\n\t} else if (key === 'up' && this.isKeyUp && this.y > 45) {\n\t\tthis.direction = 'up';\n\t\tthis.speed = 3100;\n\t} else if (key === 'up' && this.isKeyUp && this.y < 45) {\n\t\t// Player wins\n\t\tplayer.winGame();\n\t} else if (key === 'down' && this.isKeyUp && this.y < 400) {\n\t\tthis.direction = 'down';\n\t\tthis.speed = 3100;\n\t}\n}\n\n// Player render() method: draws player character on the screen\n//Player.prototype.render = function () {\n//\tctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n//}\n\n/* Player method: \n * at collision decrease lives by 1\n * hide a heart\n */\nPlayer.prototype.loseLife = function (life) {\n\tplayer.lives--;\n\tlife.style.display = 'none';\n\tplayer.x = 200;\n\tplayer.y = 400;\n}\n\n/*\n * Invoked when player wins the game:\n * displays win modal\n * reloads page if player hits enter or clicks on modal button\n */\nPlayer.prototype.winGame = function () {\n\tmodalWin.style.display = 'block';\n\n\tdocument.addEventListener('keydown', function (e) {\n\t\tif (e.keyCode === 13) {\n\t\t\treloadAfterWin();\n\t\t}\n\t})\n\n\tmodalBtnWin.addEventListener('click', function () {\n\t\treloadAfterWin();\n\t})\n}\n\n/*\n * Player method: \n * show game over modal\n * reset game on spacebar press\n */\nPlayer.prototype.endGame = function () {\n\tplayer.isGameOver = true;\n\tmodalGameOver.style.display = 'block';\n\t['keydown', 'ontouchstart'].forEach(listener =>\n\t\tdocument.addEventListener(listener, function (e) {\n\t\t\t// Handle spacebar/enter press or taps on screen\n\t\t\tif ((listener === 'keydown' && e.keyCode === 32 || e.keyCode === 13) ||\n\t\t\t\tlistener === 'ontouchstart') {\n\t\t\t\twindow.location.reload(false);\n\t\t\t}\n\t\t}, false)\n\t)\n}\n\n// Instantiate player object\nvar player = new Player(200, 400, 80, 45, 0);\nplayer.sprite = localStorage.myChar ? localStorage.myChar : 'images/char-boy.png';\n\n// Instantiate enemy objects\nvar enemy0 = new Enemy(-120, 60, 80, 40, 500, 'images/enemy-bug.png');\nvar enemy1 = new Enemy(-120, 60, 80, 40, 500, 'images/enemy-bug.png');\nvar enemy2 = new Enemy(-120, 60, 80, 40, 500, 'images/enemy-bug.png');\n\nvar enemy0, enemy1, enemy2;\n\n// Instantiate allEnemies object\nvar allEnemies = [];\n\n// Push enemies into allEnemies[]\nallEnemies.push(enemy0, enemy1, enemy2);\n\n/*\n * when player wins it sets isCharSelected to false\n * and reloads the page\n */\nfunction reloadAfterWin() {\n\t//isCharSelected = false;\n\twindow.location.reload(false);\n}\n\n\n// This listens for key presses and sends the keys to your\ndocument.addEventListener('keyup', function (e) {\n\tvar allowedKeys = {\n\t\t37: 'left',\n\t\t38: 'up',\n\t\t39: 'right',\n\t\t40: 'down'\n\t};\n\n\tplayer.isKeyUp = true;\n\n\tplayer.handleInput(allowedKeys[e.keyCode]);\n\n});\n\n/*\n * Iterate through DOM character div containers\n * When user clicks a character:\n * if other characters have class 'selected', remove it abd sets isCharSelected to false\n * add class 'selected' to clicked character\n * set isCharSelected to true\n * based on character's id, set player.sprite to related image url\n */\nfor (let character of characters) {\n\tcharacter.addEventListener('click', function (e) {\n\n\t\tfor (let character of characters) {\n\t\t\tcharacter.classList.remove('selected');\n\t\t\tisCharSelected = false;\n\t\t}\n\n\t\tthis.classList.add('selected');\n\n\t\tsavedChar = getIndex(character);\n\n\t\tisCharSelected = true;\n\n\t\tlocalStorage.setItem('myValue', savedChar);\n\n\t\tif (e.target.id === 'boy') {\n\t\t\tplayer.sprite = 'images/char-boy.png';\n\t\t} else if (e.target.id === 'cat-girl') {\n\t\t\tplayer.sprite = 'images/char-cat-girl.png';\n\t\t} else if (e.target.id === 'horn-girl') {\n\t\t\tplayer.sprite = 'images/char-horn-girl.png';\n\t\t} else if (e.target.id === 'pink-girl') {\n\t\t\tplayer.sprite = 'images/char-pink-girl.png';\n\t\t} else {\n\t\t\tplayer.sprite = 'images/char-princess-girl.png';\n\t\t}\n\n\t\tlocalStorage.setItem('myChar', player.sprite);\n\t\tconsole.log(localStorage);\n\n\t})\n}\n\n/*\n * On character modal. If and when user clicks the button:\n * if no character was selected, don't do anything\n * else hide modal\n */\nmodalBtnC.addEventListener('click', function () {\n\tif (isCharSelected == false) {\n\t\treturn;\n\t}\n\tmodalC.style.display = 'none';\n})\n\nfunction getIndex(el) {\n\tlet children = el.parentElement.children,\n\t\ti;\n\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t// Chek if el at position i is the selected character\n\t\t// if so, get its index\n\t\tif (children[i] === el) {\n\t\t\treturn i;\n\t\t}\n\t}\n}\n","/* Engine.js\n * This file provides the game loop functionality (update entities and render),\n * draws the initial game board on the screen, and then calls the update and\n * render methods on your player and enemy objects (defined in your app.js).\n *\n * A game engine works by drawing the entire game screen over and over, kind of\n * like a flipbook you may have created as a kid. When your player moves across\n * the screen, it may look like just that image/character is moving or being\n * drawn but that is not the case. What's really happening is the entire \"scene\"\n * is being drawn over and over, presenting the illusion of animation.\n *\n * This engine makes the canvas' context (ctx) object globally available to make \n * writing app.js a little simpler to work with.\n */\n\nvar Engine = (function (global) {\n\t/* Predefine the variables we'll be using within this scope,\n\t * create the canvas element, grab the 2D context for that canvas\n\t * set the canvas elements height/width and add it to the DOM.\n\t */\n\tvar doc = global.document,\n\t\twin = global.window,\n\t\tcanvas = doc.createElement('canvas'),\n\t\tctx = canvas.getContext('2d'),\n\t\tlastTime;\n\n\tcanvas.width = 505;\n\tcanvas.height = 606;\n\tdoc.body.appendChild(canvas);\n\n\t/* This function serves as the kickoff point for the game loop itself\n\t * and handles properly calling the update and render methods.\n\t */\n\tfunction main() {\n\t\t/* Get our time delta information which is required if your game\n\t\t * requires smooth animation. Because everyone's computer processes\n\t\t * instructions at different speeds we need a constant value that\n\t\t * would be the same for everyone (regardless of how fast their\n\t\t * computer is) - hurray time!\n\t\t */\n\n\t\tvar now = Date.now(),\n\t\t\tdt = (now - lastTime) / 1000.0,\n\t\t\tsprite = \"\";\n\n\t\t/* Call our update/render functions, pass along the time delta to\n\t\t * our update function since it may be used for smooth animation.\n\t\t */\n\t\tif (player.isGameOver == false) {\n\t\t\tupdate(dt);\n\t\t}\n\t\trender();\n\n\t\t/* Set our lastTime variable which is used to determine the time delta\n\t\t * for the next time this function is called.\n\t\t */\n\t\tlastTime = now;\n\n\t\t/* Use the browser's requestAnimationFrame function to call this\n\t\t * function again as soon as the browser is able to draw another frame.\n\t\t */\n\t\tif (player.isGameOver == false) {\n\t\t\twin.requestAnimationFrame(main);\n\t\t}\n\t}\n\n\t/* This function does some initial setup that should only occur once,\n\t * particularly setting the lastTime variable that is required for the\n\t * game loop.\n\t */\n\tfunction init() {\n\t\tlastTime = Date.now();\n\t\tmain();\n\t}\n\n\t/* This function is called by main (our game loop) and itself calls all\n\t * of the functions which may need to update entity's data. Based on how\n\t * you implement your collision detection (when two entities occupy the\n\t * same space, for instance when your character should die), you may find\n\t * the need to add an additional function call here. For now, we've left\n\t * it commented out - you may or may not want to implement this\n\t * functionality this way (you could just implement collision detection\n\t * on the entities themselves within your app.js file).\n\t */\n\tfunction update(dt) {\n\t\tupdateEntities(dt);\n\t\tcheckCollisions();\n\t}\n\n\t/* This is called by the update function and loops through all of the\n\t * objects within your allEnemies array as defined in app.js and calls\n\t * their update() methods. It will then call the update function for your\n\t * player object. These update methods should focus purely on updating\n\t * the data/properties related to the object. Do your drawing in your\n\t * render methods.\n\t */\n\tfunction updateEntities(dt) {\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.update(dt);\n\t\t});\n\t\tplayer.update(dt);\n\t}\n\n\n\t/* This checks for collisions between an enemy and player\n\t * Since entities are on axes and have width and height\n\t * it's possible to check for gaps between them. \n\t * If that's the case then a collision happend,\n\t * and the player goes back to its initial position.\n\t */\n\tfunction checkCollisions() {\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.handleCollisions();\n\t\t})\n\t}\n\n\t/* This function initially draws the \"game level\", it will then call\n\t * the renderEntities function. Remember, this function is called every\n\t * game tick (or loop of the game engine) because that's how games work -\n\t * they are flipbooks creating the illusion of animation but in reality\n\t * they are just drawing the entire screen over and over.\n\t */\n\n\tfunction render() {\n\t\t/* This array holds the relative URL to the image used\n\t\t * for that particular row of the game level.\n\t\t */\n\t\tvar rowImages = [\n                'images/water-block.png', // Top row is water\n                'images/stone-block.png', // Row 1 of 3 of stone\n                'images/stone-block.png', // Row 2 of 3 of stone\n                'images/stone-block.png', // Row 3 of 3 of stone\n                'images/grass-block.png', // Row 1 of 2 of grass\n                'images/grass-block.png' // Row 2 of 2 of grass\n            ],\n\t\t\tnumRows = 6,\n\t\t\tnumCols = 5,\n\t\t\trow, col;\n\n\t\t// Before drawing, clear existing canvas\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\n\t\t/* Loop through the number of rows and columns we've defined above\n\t\t * and, using the rowImages array, draw the correct image for that\n\t\t * portion of the \"grid\"\n\t\t */\n\t\tfor (row = 0; row < numRows; row++) {\n\t\t\tfor (col = 0; col < numCols; col++) {\n\t\t\t\t/* The drawImage function of the canvas' context element\n\t\t\t\t * requires 3 parameters: the image to draw, the x coordinate\n\t\t\t\t * to start drawing and the y coordinate to start drawing.\n\t\t\t\t * We're using our Resources helpers to refer to our images\n\t\t\t\t * so that we get the benefits of caching these images, since\n\t\t\t\t * we're using them over and over.\n\t\t\t\t */\n\t\t\t\tctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\n\t\t\t}\n\t\t}\n\n\t\trenderEntities();\n\t}\n\n\t/* This function is called by the render function and is called on each game\n\t * tick. Its purpose is to then call the render functions you have defined\n\t * on your enemy and player entities within app.js\n\t */\n\tfunction renderEntities() {\n\t\t/* Loop through all of the objects within the allEnemies array and call\n\t\t * the render function you have defined.\n\t\t */\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.render();\n\t\t});\n\t\tplayer.render();\n\t}\n\n\t/* This function does nothing but it could have been a good place to\n\t * handle game reset states - maybe a new game menu or a game over screen\n\t * those sorts of things. It's only called once by the init() method.\n\t */\n\t// function reset(){}\n\n\t/* Go ahead and load all of the images we know we're going to need to\n\t * draw our game level. Then set init as the callback method, so that when\n\t * all of these images are properly loaded our game will start.\n\t */\n\n\tResources.load([\n        'images/stone-block.png',\n        'images/water-block.png',\n        'images/grass-block.png',\n        'images/enemy-bug.png',\n        'images/char-boy.png',\n\t\t'images/char-cat-girl.png',\n\t\t'images/char-horn-girl.png',\n\t\t'images/char-pink-girl.png',\n\t\t'images/char-princess-girl.png'\n\t]);\n\tResources.onReady(init);\n\n\t/* Assign the canvas' context object to the global variable (the window\n\t * object when run in a browser) so that developers can use it more easily\n\t * from within their app.js files.\n\t */\n\tglobal.ctx = ctx;\n})(this);\n"]}