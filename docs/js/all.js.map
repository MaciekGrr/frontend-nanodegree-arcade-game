{"version":3,"sources":["js/resources.js","js/app.js","js/engine.js"],"names":["resourceCache","readyCallbacks","_load","url","img","Image","onload","isReady","forEach","func","src","ready","k","hasOwnProperty","window","Resources","load","urlOrArr","Array","get","onReady","push","modalC","document","getElementById","modalWin","modalGameOver","modalBtnWin","modalBtnC","characters","getElementsByClassName","isCharSelected","heartN1","heartN2","heartN3","item","localStorage","getItem","classList","add","Enemy","x","y","this","width","height","speed","sprite","prototype","update","dt","randomN","Math","floor","random","render","ctx","drawImage","handleCollisions","player","lives","loseLife","life1","life2","isGameOver","setTimeout","endGame","Player","isKeyUp","direction","myChar","console","log","life3","handleInput","key","winGame","life","style","display","addEventListener","e","keyCode","reloadAfterWin","listener","location","reload","enemy0","enemy1","enemy2","allEnemies","37","38","39","40","character","remove","savedChar","getIndex","setItem","target","id","el","children","parentElement","i","len","length","Engine","global","lastTime","doc","win","canvas","createElement","getContext","main","now","Date","enemy","updateEntities","row","col","rowImages","clearRect","requestAnimationFrame","body","appendChild"],"mappings":"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","file":"all.js","sourcesContent":["    /* Resources.js\n * This is simply an image loading utility. It eases the process of loading\n * image files so that they can be used within your game. It also includes\n * a simple \"caching\" layer so it will reuse cached images if you attempt\n * to load the same image multiple times.\n */\n(function() {\n    var resourceCache = {};\n    var loading = [];\n    var readyCallbacks = [];\n\n    /* This is the publicly accessible image loading function. It accepts\n     * an array of strings pointing to image files or a string for a single\n     * image. It will then call our private image loading function accordingly.\n     */\n    function load(urlOrArr) {\n        if(urlOrArr instanceof Array) {\n            /* If the developer passed in an array of images\n             * loop through each value and call our image\n             * loader on that image file\n             */\n            urlOrArr.forEach(function(url) {\n                _load(url);\n            });\n        } else {\n            /* The developer did not pass an array to this function,\n             * assume the value is a string and call our image loader\n             * directly.\n             */\n            _load(urlOrArr);\n        }\n    }\n\n    /* This is our private image loader function, it is\n     * called by the public image loader function.\n     */\n    function _load(url) {\n        if(resourceCache[url]) {\n            /* If this URL has been previously loaded it will exist within\n             * our resourceCache array. Just return that image rather\n             * re-loading the image.\n             */\n            return resourceCache[url];\n        } else {\n            /* This URL has not been previously loaded and is not present\n             * within our cache; we'll need to load this image.\n             */\n            var img = new Image();\n            img.onload = function() {\n                /* Once our image has properly loaded, add it to our cache\n                 * so that we can simply return this image if the developer\n                 * attempts to load this file in the future.\n                 */\n                resourceCache[url] = img;\n\n                /* Once the image is actually loaded and properly cached,\n                 * call all of the onReady() callbacks we have defined.\n                 */\n                if(isReady()) {\n                    readyCallbacks.forEach(function(func) { func(); });\n                }\n            };\n\n            /* Set the initial cache value to false, this will change when\n             * the image's onload event handler is called. Finally, point\n             * the image's src attribute to the passed in URL.\n             */\n            resourceCache[url] = false;\n            img.src = url;\n        }\n    }\n\n    /* This is used by developers to grab references to images they know\n     * have been previously loaded. If an image is cached, this functions\n     * the same as calling load() on that URL.\n     */\n    function get(url) {\n        return resourceCache[url];\n    }\n\n    /* This function determines if all of the images that have been requested\n     * for loading have in fact been properly loaded.\n     */\n    function isReady() {\n        var ready = true;\n        for(var k in resourceCache) {\n            if(resourceCache.hasOwnProperty(k) &&\n               !resourceCache[k]) {\n                ready = false;\n            }\n        }\n        return ready;\n    }\n\n    /* This function will add a function to the callback stack that is called\n     * when all requested images are properly loaded.\n     */\n    function onReady(func) {\n        readyCallbacks.push(func);\n    }\n\n    /* This object defines the publicly accessible functions available to\n     * developers by creating a global Resources object.\n     */\n    window.Resources = {\n        load: load,\n        get: get,\n        onReady: onReady,\n        isReady: isReady\n    };\n})();\n","const modalC = document.getElementById('c-modal'),\n\tmodalWin = document.getElementById('win-modal'),\n\tmodalGameOver = document.getElementById('game-over-modal'),\n\tmodalBtnWin = document.getElementById('modal-btn-win'),\n\tmodalBtnC = document.getElementById('modal-btn-c');\nvar characters = modalC.getElementsByClassName('modal__character'),\n\tisCharSelected = true,\n\theartN1 = document.getElementById('heart1'),\n\theartN2 = document.getElementById('heart2'),\n\theartN3 = document.getElementById('heart3');\n\n(function () {\n\tcharacters.item(localStorage.getItem('myValue')).classList.add('selected');\n\t//player.sprite = localStorage.getItem('myChar');\n\tisCharSelected = true;\n})();\n\n/*\n\t-------------------------------------------ENEMY CLASS\n*/\n\n// Enemies our player must avoid\nvar Enemy = function (x, y) {\n\t// Variables applied to each of our instances go here,\n\t// we've provided one for you to get started\n\n\t// Set enemy location\n\tthis.x = -120;\n\n\t// Set enemy initial location\n\tthis.y = 60;\n\n\t// set width and height: to use in Enemy.handleCollision() method \n\tthis.width = 80;\n\tthis.height = 40;\n\n\t// Set enemy initial speed\n\tthis.speed = 250; // low\n\tthis.speed = 400; // medium\n\tthis.speed = 500; // high\n\n\t// The image/sprite for our enemies, this uses a helper we've provided to easily load images\n\tthis.sprite = 'images/enemy-bug.png';\n};\n\n// Update the enemy's position, required method for game\n// Parameter: dt, a time delta between ticks\nEnemy.prototype.update = function (dt) {\n\n\t// Calculate random number between 1 and 3\n\tlet randomN = Math.floor((Math.random() * 3) + 1);\n\n\t// When enemy is off-screen\n\t// randomize new position at which it's created\n\tif (this.x > 520) {\n\n\t\t// Reset x coordinate to off-screen\n\t\t// left side\n\t\tthis.x = -120;\n\n\t\t// Generate enemy on one of the stone rows\n\t\tif (randomN === 1) {\n\t\t\tthis.y = 60;\n\t\t\tthis.speed = 500;\n\t\t} else if (randomN === 2) {\n\t\t\tthis.y = 140;\n\t\t\tthis.speed = 600;\n\t\t} else if (randomN === 3) {\n\t\t\tthis.y = 230;\n\t\t\tthis.speed = 700;\n\t\t}\n\t}\n\n\tthis.x += (this.speed * dt);\n\n};\n\n// Draw the enemy on the screen, required method for game\nEnemy.prototype.render = function () {\n\tctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n};\n\n/* \n * Parameter: check if enemy and player collide.\n * If so, reset player to its initial location\n */\nEnemy.prototype.handleCollisions = function () {\n\n\tif (this.x < player.x + player.width &&\n\t\tthis.x + this.width > player.x &&\n\t\tthis.y < player.y + player.height &&\n\t\tthis.y + this.height > player.y) {\n\n\t\t// Handle lives \n\t\tif (player.lives === 3) {\n\t\t\tplayer.loseLife(player.life1);\n\t\t} else if (player.lives === 2) {\n\t\t\tplayer.loseLife(player.life2);\n\t\t} else {\n\t\t\t// Handle Game Over\n\t\t\tplayer.isGameOver = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\tplayer.endGame();\n\t\t\t}, 1000);\n\t\t}\n\t}\n}\n\n\n/*\n\t----------------------------------------------PLAYER CLASS\n */\n\n// Player class\nvar Player = function () {\n\n\t// Set initial location\n\tthis.x = 200;\n\tthis.y = 400;\n\n\tthis.width = 80;\n\tthis.height = 40;\n\n\t// Set initial speed\n\tthis.speed;\n\n\t// Boolean: to use in Player.handleInput() method\n\tthis.isKeyUp = true;\n\n\t// Set player directon. Empty.\n\t// It changes in player.handleInput() to give direction to movement\n\tthis.direction = '';\n\n\t/*\n\t * Set player character:\n\t * use localStorage to retreive last saved sprite's path\n\t * if theres' one, set it for our sprite\n\t * else use predefined sprite (char-boy)\n\t */\n\tif (localStorage.myChar) {\n\t\tconsole.log(localStorage.myChar);\n\t\tthis.sprite = localStorage.myChar;\n\t} else {\n\t\tthis.sprite = 'images/char-boy.png';\n\t}\n\n\t// Set player initial lives number\n\tthis.lives = 3;\n\n\t// Assign hearts elements to three variables. To use in player.loseLife() method\n\tthis.life1 = heartN1;\n\tthis.life2 = heartN2;\n\tthis.life3 = heartN3;\n\n\t// Boolean. Use it to check if game is over \n\tthis.isGameOver = false;\n}\n\n// Updates player position\nPlayer.prototype.update = function (dt) {\n\n\tif (this.direction === 'right') {\n\t\tthis.x += (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'left') {\n\t\tthis.x -= (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'up') {\n\t\tthis.y -= (this.speed * dt);\n\t\tthis.speed = 0;\n\t} else if (this.direction === 'down') {\n\t\tthis.y += (this.speed * dt);\n\t\tthis.speed = 0;\n\t}\n\n}\n\n/* Player handleInput() method:\n * based on key input sets direction, speed\n * and checks win conditions\n */\nPlayer.prototype.handleInput = function (key) {\n\n\t// handle direction and speed of movement\n\tif (key === 'right' && this.isKeyUp && this.x < 380) {\n\t\tthis.direction = 'right';\n\t\tthis.speed = 4000;\n\t} else if (key === 'left' && this.isKeyUp && this.x > 33) {\n\t\tthis.direction = 'left';\n\t\tthis.speed = 4000;\n\t} else if (key === 'up' && this.isKeyUp && this.y > 45) {\n\t\tthis.direction = 'up';\n\t\tthis.speed = 3100;\n\t} else if (key === 'up' && this.isKeyUp && this.y < 45) {\n\t\t// Player wins\n\t\tplayer.winGame();\n\t} else if (key === 'down' && this.isKeyUp && this.y < 400) {\n\t\tthis.direction = 'down';\n\t\tthis.speed = 3100;\n\t}\n}\n\n// Player render() method: draws player character on the screen\nPlayer.prototype.render = function () {\n\tctx.drawImage(Resources.get(this.sprite), this.x, this.y);\n}\n\n/* Player method: \n * at collision decrease lives by 1\n * hide a heart\n */\nPlayer.prototype.loseLife = function (life) {\n\tplayer.lives--;\n\tlife.style.display = 'none';\n\tplayer.x = 200;\n\tplayer.y = 400;\n}\n\n/*\n * Invoked when player wins the game:\n * displays win modal\n * reloads page if player hits enter or clicks on modal button\n */\nPlayer.prototype.winGame = function () {\n\tmodalWin.style.display = 'block';\n\n\tdocument.addEventListener('keydown', function (e) {\n\t\tif (e.keyCode === 13) {\n\t\t\treloadAfterWin();\n\t\t}\n\t})\n\n\tmodalBtnWin.addEventListener('click', function () {\n\t\treloadAfterWin();\n\t})\n}\n\n/*\n * Player method: \n * show game over modal\n * reset game on spacebar press\n */\nPlayer.prototype.endGame = function () {\n\tplayer.isGameOver = true;\n\tmodalGameOver.style.display = 'block';\n\t['keydown', 'ontouchstart'].forEach(listener =>\n\t\tdocument.addEventListener(listener, function (e) {\n\t\t\t// Handle spacebar/enter press or taps on screen\n\t\t\tif ((listener === 'keydown' && e.keyCode === 32 || e.keyCode === 13) || \n\t\t\t\t listener === 'ontouchstart') {\n\t\t\t\twindow.location.reload(false);\n\t\t\t}\n\t\t}, false)\n\t)\n}\n\n// Instantiate player object\nvar player = new Player();\n\n// Instantiate enemy objects\nvar enemy0 = new Enemy();\nvar enemy1 = new Enemy();\nvar enemy2 = new Enemy();\n\n// Instantiate allEnemies object\nvar allEnemies = [];\n\n// Push enemies into allEnemies[]\nallEnemies.push(enemy0, enemy1, enemy2);\n\n/*\n * when player wins it sets isCharSelected to false\n * and reloads the page\n */\nfunction reloadAfterWin() {\n\t//isCharSelected = false;\n\twindow.location.reload(false);\n}\n\n\n// This listens for key presses and sends the keys to your\ndocument.addEventListener('keyup', function (e) {\n\tvar allowedKeys = {\n\t\t37: 'left',\n\t\t38: 'up',\n\t\t39: 'right',\n\t\t40: 'down'\n\t};\n\n\tplayer.isKeyUp = true;\n\n\tplayer.handleInput(allowedKeys[e.keyCode]);\n\n});\n\n/*\n * Iterate through DOM character div containers\n * When user clicks a character:\n * if other characters have class 'selected', remove it abd sets isCharSelected to false\n * add class 'selected' to clicked character\n * set isCharSelected to true\n * based on character's id, set player.sprite to related image url\n */\nfor (let character of characters) {\n\tcharacter.addEventListener('click', function (e) {\n\n\t\tfor (let character of characters) {\n\t\t\tcharacter.classList.remove('selected');\n\t\t\tisCharSelected = false;\n\t\t}\n\n\t\tthis.classList.add('selected');\n\n\t\tsavedChar = getIndex(character);\n\n\t\tisCharSelected = true;\n\n\t\tlocalStorage.setItem('myValue', savedChar);\n\n\t\tif (e.target.id === 'boy') {\n\t\t\tplayer.sprite = 'images/char-boy.png';\n\t\t} else if (e.target.id === 'cat-girl') {\n\t\t\tplayer.sprite = 'images/char-cat-girl.png';\n\t\t} else if (e.target.id === 'horn-girl') {\n\t\t\tplayer.sprite = 'images/char-horn-girl.png';\n\t\t} else if (e.target.id === 'pink-girl') {\n\t\t\tplayer.sprite = 'images/char-pink-girl.png';\n\t\t} else {\n\t\t\tplayer.sprite = 'images/char-princess-girl.png';\n\t\t}\n\n\t\tlocalStorage.setItem('myChar', player.sprite);\n\t\tconsole.log(localStorage);\n\n\t})\n}\n\n/*\n * On character modal. If and when user clicks the button:\n * if no character was selected, don't do anything\n * else hide modal\n */\nmodalBtnC.addEventListener('click', function () {\n\tif (isCharSelected == false) {\n\t\treturn;\n\t}\n\tmodalC.style.display = 'none';\n})\n\nfunction getIndex(el) {\n\tlet children = el.parentElement.children,\n\t\ti;\n\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t// Chek if el at position i is the selected character\n\t\t// if so, get its index\n\t\tif (children[i] === el) {\n\t\t\treturn i;\n\t\t}\n\t}\n}\n","/* Engine.js\n * This file provides the game loop functionality (update entities and render),\n * draws the initial game board on the screen, and then calls the update and\n * render methods on your player and enemy objects (defined in your app.js).\n *\n * A game engine works by drawing the entire game screen over and over, kind of\n * like a flipbook you may have created as a kid. When your player moves across\n * the screen, it may look like just that image/character is moving or being\n * drawn but that is not the case. What's really happening is the entire \"scene\"\n * is being drawn over and over, presenting the illusion of animation.\n *\n * This engine makes the canvas' context (ctx) object globally available to make \n * writing app.js a little simpler to work with.\n */\n\nvar Engine = (function (global) {\n\t/* Predefine the variables we'll be using within this scope,\n\t * create the canvas element, grab the 2D context for that canvas\n\t * set the canvas elements height/width and add it to the DOM.\n\t */\n\tvar doc = global.document,\n\t\twin = global.window,\n\t\tcanvas = doc.createElement('canvas'),\n\t\tctx = canvas.getContext('2d'),\n\t\tlastTime;\n\n\tcanvas.width = 505;\n\tcanvas.height = 606;\n\tdoc.body.appendChild(canvas);\n\n\t/* This function serves as the kickoff point for the game loop itself\n\t * and handles properly calling the update and render methods.\n\t */\n\tfunction main() {\n\t\t/* Get our time delta information which is required if your game\n\t\t * requires smooth animation. Because everyone's computer processes\n\t\t * instructions at different speeds we need a constant value that\n\t\t * would be the same for everyone (regardless of how fast their\n\t\t * computer is) - hurray time!\n\t\t */\n\n\t\tvar now = Date.now(),\n\t\t\tdt = (now - lastTime) / 1000.0,\n\t\t\tsprite = \"\";\n\n\t\t/* Call our update/render functions, pass along the time delta to\n\t\t * our update function since it may be used for smooth animation.\n\t\t */\n\t\tif (player.isGameOver == false) {\n\t\t\tupdate(dt);\n\t\t}\n\t\trender();\n\n\t\t/* Set our lastTime variable which is used to determine the time delta\n\t\t * for the next time this function is called.\n\t\t */\n\t\tlastTime = now;\n\n\t\t/* Use the browser's requestAnimationFrame function to call this\n\t\t * function again as soon as the browser is able to draw another frame.\n\t\t */\n\t\tif (player.isGameOver == false) {\n\t\t\twin.requestAnimationFrame(main);\n\t\t}\n\t}\n\n\t/* This function does some initial setup that should only occur once,\n\t * particularly setting the lastTime variable that is required for the\n\t * game loop.\n\t */\n\tfunction init() {\n\t\tlastTime = Date.now();\n\t\tmain();\n\t\t//reset();\n\t}\n\n\t/* This function is called by main (our game loop) and itself calls all\n\t * of the functions which may need to update entity's data. Based on how\n\t * you implement your collision detection (when two entities occupy the\n\t * same space, for instance when your character should die), you may find\n\t * the need to add an additional function call here. For now, we've left\n\t * it commented out - you may or may not want to implement this\n\t * functionality this way (you could just implement collision detection\n\t * on the entities themselves within your app.js file).\n\t */\n\tfunction update(dt) {\n\t\tupdateEntities(dt);\n\t\tcheckCollisions();\n\t}\n\n\t/* This is called by the update function and loops through all of the\n\t * objects within your allEnemies array as defined in app.js and calls\n\t * their update() methods. It will then call the update function for your\n\t * player object. These update methods should focus purely on updating\n\t * the data/properties related to the object. Do your drawing in your\n\t * render methods.\n\t */\n\tfunction updateEntities(dt) {\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.update(dt);\n\t\t});\n\t\tplayer.update(dt);\n\t}\n\n\n\t/* This checks for collisions between an enemy and player\n\t * Since entities are on axes and have width and height\n\t * it's possible to check for gaps between them. \n\t * If that's the case then a collision happend,\n\t * and the player goes back to its initial position.\n\t */\n\tfunction checkCollisions() {\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.handleCollisions();\n\t\t})\n\t}\n\n\t/* This function initially draws the \"game level\", it will then call\n\t * the renderEntities function. Remember, this function is called every\n\t * game tick (or loop of the game engine) because that's how games work -\n\t * they are flipbooks creating the illusion of animation but in reality\n\t * they are just drawing the entire screen over and over.\n\t */\n\n\tfunction render() {\n\t\t/* This array holds the relative URL to the image used\n\t\t * for that particular row of the game level.\n\t\t */\n\t\tvar rowImages = [\n                'images/water-block.png', // Top row is water\n                'images/stone-block.png', // Row 1 of 3 of stone\n                'images/stone-block.png', // Row 2 of 3 of stone\n                'images/stone-block.png', // Row 3 of 3 of stone\n                'images/grass-block.png', // Row 1 of 2 of grass\n                'images/grass-block.png' // Row 2 of 2 of grass\n            ],\n\t\t\tnumRows = 6,\n\t\t\tnumCols = 5,\n\t\t\trow, col;\n\n\t\t// Before drawing, clear existing canvas\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height)\n\n\t\t/* Loop through the number of rows and columns we've defined above\n\t\t * and, using the rowImages array, draw the correct image for that\n\t\t * portion of the \"grid\"\n\t\t */\n\t\tfor (row = 0; row < numRows; row++) {\n\t\t\tfor (col = 0; col < numCols; col++) {\n\t\t\t\t/* The drawImage function of the canvas' context element\n\t\t\t\t * requires 3 parameters: the image to draw, the x coordinate\n\t\t\t\t * to start drawing and the y coordinate to start drawing.\n\t\t\t\t * We're using our Resources helpers to refer to our images\n\t\t\t\t * so that we get the benefits of caching these images, since\n\t\t\t\t * we're using them over and over.\n\t\t\t\t */\n\t\t\t\tctx.drawImage(Resources.get(rowImages[row]), col * 101, row * 83);\n\t\t\t}\n\t\t}\n\n\t\trenderEntities();\n\t}\n\n\t/* This function is called by the render function and is called on each game\n\t * tick. Its purpose is to then call the render functions you have defined\n\t * on your enemy and player entities within app.js\n\t */\n\tfunction renderEntities() {\n\t\t/* Loop through all of the objects within the allEnemies array and call\n\t\t * the render function you have defined.\n\t\t */\n\t\tallEnemies.forEach(function (enemy) {\n\t\t\tenemy.render();\n\t\t});\n\t\tplayer.render();\n\t}\n\n\t/* This function does nothing but it could have been a good place to\n\t * handle game reset states - maybe a new game menu or a game over screen\n\t * those sorts of things. It's only called once by the init() method.\n\t */\n\t// function reset(){}\n\n\t/* Go ahead and load all of the images we know we're going to need to\n\t * draw our game level. Then set init as the callback method, so that when\n\t * all of these images are properly loaded our game will start.\n\t */\n\n\tResources.load([\n        'images/stone-block.png',\n        'images/water-block.png',\n        'images/grass-block.png',\n        'images/enemy-bug.png',\n        'images/char-boy.png',\n\t\t'images/char-cat-girl.png',\n\t\t'images/char-horn-girl.png',\n\t\t'images/char-pink-girl.png',\n\t\t'images/char-princess-girl.png'\n\t]);\n\tResources.onReady(init);\n\n\t/* Assign the canvas' context object to the global variable (the window\n\t * object when run in a browser) so that developers can use it more easily\n\t * from within their app.js files.\n\t */\n\tglobal.ctx = ctx;\n})(this);\n"]}